<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>weac.mixins API documentation</title>
<meta name="description" content="Mixins for the elastic analysis of layered snow slabs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weac.mixins</code></h1>
</header>
<section id="section-intro">
<p>Mixins for the elastic analysis of layered snow slabs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Mixins for the elastic analysis of layered snow slabs.&#34;&#34;&#34;
# pylint: disable=invalid-name,too-many-locals,too-many-arguments

# Standard library imports
from functools import partial

# Third party imports
import numpy as np
from scipy.integrate import romberg


class FieldQuantitiesMixin:
    &#34;&#34;&#34;
    Mixin for field quantities.

    Provides methods for the computation of displacements, stresses,
    strains, and energy release rates from the solution vector.
    &#34;&#34;&#34;

    # pylint: disable=no-self-use
    def w(self, Z):
        &#34;&#34;&#34;
        Get centerline deflection w.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        w : float
            Deflection w (mm) of the slab.
        &#34;&#34;&#34;
        return Z[2, :]

    def wp(self, Z):
        &#34;&#34;&#34;
        Get first derivative w&#39; of the centerline deflection.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        wp : float
            First derivative w&#39; of the deflection of the slab.
        &#34;&#34;&#34;
        return Z[3, :]

    def psi(self, Z):
        &#34;&#34;&#34;
        Get midplane rotation psi.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        psi : float
            Midplane rotation psi (radians) of the slab.
        &#34;&#34;&#34;
        return Z[4, :]

    def psip(self, Z):
        &#34;&#34;&#34;
        Get first derivative psi&#39; of the midplane rotation.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        psip : float
            First derivative psi&#39; of the midplane rotation (radians/mm)
             of the slab.
        &#34;&#34;&#34;
        return Z[5, :]

    # pylint: enable=no-self-use
    def u(self, Z, z0):
        &#34;&#34;&#34;
        Get horizontal displacement u = u0 + z0 psi.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        z0 : float
            Z-coordinate (mm) where u is to be evaluated.

        Returns
        -------
        u : float
            Horizontal displacement u (mm) of the slab.
        &#34;&#34;&#34;
        return Z[0, :] + z0*self.psi(Z)

    def up(self, Z, z0):
        &#34;&#34;&#34;
        Get first derivative of the horizontal displacement.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        z0 : float
            Z-coordinate (mm) where u is to be evaluated.

        Returns
        -------
        up : float
            First derivative u&#39; = u0&#39; + z0 psi&#39; of the horizontal
            displacement of the slab.
        &#34;&#34;&#34;
        return Z[1, :] + z0*self.psip(Z)

    def N(self, Z):
        &#34;&#34;&#34;
        Get the axial normal force N = A11 u&#39; + B11 psi&#39; in the slab.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        N : float
            Axial normal force N (N) in the slab.
        &#34;&#34;&#34;
        return self.A11*Z[1, :] + self.B11*Z[5, :]

    def M(self, Z):
        &#34;&#34;&#34;
        Get bending moment M = B11 u&#39; + D11 psi&#39; in the slab.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        M : float
            Bending moment M (Nmm) in the slab.
        &#34;&#34;&#34;
        return self.B11*Z[1, :] + self.D11*Z[5, :]

    def V(self, Z):
        &#34;&#34;&#34;
        Get vertical shear force V = kA55(w&#39; + psi).

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        V : float
            Vertical shear force V (N) in the slab.
        &#34;&#34;&#34;
        return self.kA55*(Z[3, :] + Z[4, :])

    def sig(self, Z):
        &#34;&#34;&#34;
        Get weak-layer normal stress.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        sig : float
            Weak-layer normal stress sigma (MPa).
        &#34;&#34;&#34;
        return -self.kn*self.w(Z)

    def tau(self, Z):
        &#34;&#34;&#34;
        Get weak-layer shear stress.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        tau : float
            Weak-layer shear stress tau (MPa).
        &#34;&#34;&#34;
        return self.kt*(self.wp(Z)*self.t/2 - self.u(Z, z0=self.h/2))

    def eps(self, Z):
        &#34;&#34;&#34;
        Get weak-layer normal strain.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        eps : float
            Weak-layer normal strain epsilon (MPa).
        &#34;&#34;&#34;
        return -self.w(Z)/self.t

    def gamma(self, Z):
        &#34;&#34;&#34;
        Get weak-layer shear strain.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        gamma : float
            Weak-layer shear strain gamma (MPa).
        &#34;&#34;&#34;
        return self.wp(Z)/2 - self.u(Z, z0=self.h/2)/self.t

    def maxp(self, Z):
        &#34;&#34;&#34;
        Get maximum principal stress in the weak layer.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        maxp : float
            Maximum principal stress (MPa) in the weak layer.
        &#34;&#34;&#34;
        sig = self.sig(Z)
        tau = self.tau(Z)
        return np.amax([[sig + np.sqrt(sig**2 + 4*tau**2),
                         sig - np.sqrt(sig**2 + 4*tau**2)]], axis=1)[0]/2

    def Gi(self, Ztip):
        &#34;&#34;&#34;
        Get mode I differential energy release rate at crack tip.

        Arguments
        ---------
        Ztip : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
            at the crack tip.

        Returns
        -------
        Gi : float
            Mode I differential energy release rate (N/mm) at the
            crack tip.
        &#34;&#34;&#34;
        return self.sig(Ztip)**2/(2*self.kn)

    def Gii(self, Ztip):
        &#34;&#34;&#34;
        Get mode II differential energy release rate at crack tip.

        Arguments
        ---------
        Ztip : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
            at the crack tip.

        Returns
        -------
        Gii : float
            Mode II differential energy release rate (N/mm) at the
            crack tip.
        &#34;&#34;&#34;
        return self.tau(Ztip)**2/(2*self.kt)

    def int1(self, x, z0, z1):
        &#34;&#34;&#34;
        Get mode I crack opening integrand at integration points xi.

        Arguments
        ---------
        x : float, ndarray
            X-coordinate where integrand is to be evaluated (mm).
        z0 : callable
            Function that returns the solution vector of the uncracked
            configuration.
        z1 : callable
            Function that returns the solution vector of the cracked
            configuration.

        Returns
        -------
        int1 : float or ndarray
            Integrant of the mode I crack opening integral.
        &#34;&#34;&#34;
        return self.sig(z0(x))*self.eps(z1(x))*self.t

    def int2(self, x, z0, z1):
        &#34;&#34;&#34;
        Get mode II crack opening integrand at integration points xi.

        Arguments
        ---------
        x: float, ndarray
            X-coordinate where integrand is to be evaluated(mm).
        z0: callable
            Function that returns the solution vector of the uncracked
            configuration.
        z1: callable
            Function that returns the solution vector of the cracked
            configuration.

        Returns
        -------
        int2 : float or ndarray
            Integrant of the mode II crack opening integral.
        &#34;&#34;&#34;
        return self.tau(z0(x))*self.gamma(z1(x))*self.t


class SolutionMixin:
    &#34;&#34;&#34;
    Mixin for the solution of boundary value problems.

    Provides methods for the assembly of the system of equations
    and for the computation of the free constants.
    &#34;&#34;&#34;

    def bc(self, z):
        &#34;&#34;&#34;
        Provide equations for free(pst) or infinite(skiers) ends.

        Arguments
        ---------
        z: ndarray
            Solution vector(6x1) at a certain position x.

        Returns
        -------
        bc: ndarray
            Boundary condition vector(lenght 3) at position x.
        &#34;&#34;&#34;
        if self.system in [&#39;pst-&#39;, &#39;-pst&#39;]:
            # Free ends
            bc = np.array([self.N(z), self.M(z), self.V(z)])
        elif self.system in [&#39;skier&#39;, &#39;skiers&#39;]:
            # Infinite ends (vanishing complementary solution)
            bc = np.array([self.u(z, z0=0), self.w(z), self.psi(z)])
        else:
            raise ValueError(
                &#39;Boundary conditions not defined for&#39;
                f&#39;system of type {self.system}.&#39;)

        return bc

    def eqs(self, zl, zr, pos=&#39;mid&#39;):
        &#34;&#34;&#34;
        Provide boundary or transmission conditions for beam segments.

        Arguments
        ---------
        zl: ndarray
            Solution vector(6x1) at left end of beam segement.
        zr: ndarray
            Solution vector(6x1) at right end of beam segement.
        pos: {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
            Determines whether the segement under consideration
            is a left boundary segement(left, l), one of the
            center segement(mid, m), or a right boundary
            segement(right, r). Default is &#39;mid&#39;.

        Returns
        -------
        eqs: ndarray
            Vector(of length 9) of boundary conditions(3) and
            transmission conditions(6) for boundary segements
            or vector of transmission conditions(of length 6+6)
            for center segments.
        &#34;&#34;&#34;
        if pos in (&#39;l&#39;, &#39;left&#39;):
            eqs = np.array([
                self.bc(zl)[0],             # Left boundary condition
                self.bc(zl)[1],             # Left boundary condition
                self.bc(zl)[2],             # Left boundary condition
                self.u(zr, z0=0),           # ui(xi = li)
                self.w(zr),                 # wi(xi = li)
                self.psi(zr),               # psii(xi = li)
                self.N(zr),                 # Ni(xi = li)
                self.M(zr),                 # Mi(xi = li)
                self.V(zr)])                # Vi(xi = li)
        elif pos in (&#39;m&#39;, &#39;mid&#39;):
            eqs = np.array([
                -self.u(zl, z0=0),          # -ui(xi = 0)
                -self.w(zl),                # -wi(xi = 0)
                -self.psi(zl),              # -psii(xi = 0)
                -self.N(zl),                # -Ni(xi = 0)
                -self.M(zl),                # -Mi(xi = 0)
                -self.V(zl),                # -Vi(xi = 0)
                self.u(zr, z0=0),           # ui(xi = li)
                self.w(zr),                 # wi(xi = li)
                self.psi(zr),               # psii(xi = li)
                self.N(zr),                 # Ni(xi = li)
                self.M(zr),                 # Mi(xi = li)
                self.V(zr)])                # Vi(xi = li)
        elif pos in (&#39;r&#39;, &#39;right&#39;):
            eqs = np.array([
                -self.u(zl, z0=0),          # -ui(xi = 0)
                -self.w(zl),                # -wi(xi = 0)
                -self.psi(zl),              # -psii(xi = 0)
                -self.N(zl),                # -Ni(xi = 0)
                -self.M(zl),                # -Mi(xi = 0)
                -self.V(zl),                # -Vi(xi = 0)
                self.bc(zr)[0],             # Right boundary condition
                self.bc(zr)[1],             # Right boundary condition
                self.bc(zr)[2]])            # Right boundary condition
        else:
            raise ValueError(
                (f&#39;Invalid position argument {pos} given. &#39;
                 &#39;Valid segment positions are l, m, and r, &#39;
                 &#39;or left, mid and right.&#39;))

        return eqs

    def calc_segments(self, li=False, mi=False, ki=False, k0=False,
                      L=1e4, a=0, m=0, **kwargs):
        &#34;&#34;&#34;
        Assemble lists defining the segments.

        This includes length(li), foundation(ki, k0), and skier weight(mi).

        Arguments
        ---------
        li: squence, optional
            List of lengths of segements(mm). Used for system &#39;skiers&#39;.
        mi: squence, optional
            List of skier weigths(kg) at segement boundaries. Used for
            system &#39;skiers&#39;.
        ki: squence, optional
            List of one bool per segement indicating whether segement
            has foundation(True) or not (False) in the cracked state.
            Used for system &#39;skiers&#39;.
        k0: squence, optional
            List of one bool per segement indicating whether segement
            has foundation(True) or not (False) in the uncracked state.
            Used for system &#39;skiers&#39;.
        L: float, optional
            Total length of model(mm). Used for systems &#39;pst-&#39;, &#39;-pst&#39;,
            and &#39;skier&#39;.
        a: float, optional
            Crack length(mm).  Used for systems &#39;pst-&#39;, &#39;-pst&#39;, and
            &#39;skier&#39;.
        m: float, optional
            Weight of skier(kg) in the axial center of the model.
            Used for system &#39;skier&#39;.

        Returns
        -------
        segments: dict
            Dictionary with lists of segement lengths(li), skier
            weights(mi), and foundation booleans in the cracked(ki)
            and ncracked(k0) configurations.
        &#34;&#34;&#34;
        _ = kwargs                                      # Unused arguments
        if self.system == &#39;skiers&#39;:
            li = np.array(li)                           # Segment lengths
            mi = np.array(mi)                           # Skier weights
            ki = np.array(ki)                           # Crack
            k0 = np.array(k0)                           # No crack
        elif self.system == &#39;pst-&#39;:
            li = np.array([L - a, a])                   # Segment lengths
            mi = np.array([0])                          # Skier weights
            ki = np.array([True, False])                # No crack
            k0 = np.array([True, True])                 # Crack
        elif self.system == &#39;-pst&#39;:
            li = np.array([a, L - a])                   # Segment lengths
            mi = np.array([0])                          # Skier weights
            ki = np.array([False, True])                # No crack
            k0 = np.array([True, True])                 # Crack
        elif self.system == &#39;skier&#39;:
            lb = (L - a)/2                              # Half bedded length
            lf = a/2                                    # Half free length
            li = np.array([lb, lf, lf, lb])             # Segment lengths
            mi = np.array([0, m, 0])                    # Skier weights
            ki = np.array([True, False, False, True])   # No crack
            k0 = np.array([True, True, True, True])     # Crack
        else:
            raise ValueError(f&#39;System {self.system} is not implemented.&#39;)

        # Fill dictionary
        segments = {
            &#39;nocrack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: k0},
            &#39;crack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki},
            &#39;both&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki, &#39;k0&#39;: k0}}

        return segments

    def assemble_and_solve(self, phi, li, mi, ki):
        &#34;&#34;&#34;
        Compute free constants for arbitrary beam assembly.

        Assemble LHS from bedded and free segments in the form
        [][zh1  0   0  ...  0   0   0][][][]  left
        [] = [zh1 zh2  0  ...  0   0   0][] + [] = []  mid
        [][0  zh2 zh3 ...  0   0   0][][][]  mid
        [z0][... ... ... ... ... ... ...][C][zp][rhs]  mid
        [][0   0   0  ... zhL zhM  0][][][]  mid
        [][0   0   0  ...  0  zhM zhN][][][]  mid
        [][0   0   0  ...  0   0  zhN][][][]  right
        and solve for constants C.

        Arguments
        ---------
        phi: float
            Inclination(degrees).
        li: ndarray
            List of lengths of segements(mm).
        mi: ndarray
            List of skier weigths(kg) at segement boundaries.
        ki: ndarray
            List of one bool per segement indicating whether segement
            has foundation(True) or not (False).

        Returns
        -------
        C: ndarray
            Matrix(6xN) of solution constants for a system of N
            segements. Columns contain the 6 constants of each segement.
        &#34;&#34;&#34;
        # --- CATCH ERRORS ----------------------------------------------------

        # No foundation
        if not any(ki):
            raise ValueError(&#39;Provide at least one bedded segment.&#39;)
        # Mismatch of number of segements and transisions
        if len(li) != len(ki) or len(li)-1 != len(mi):
            raise ValueError(&#39;Make sure len(li)=N, len(ki)=N, and &#39;
                             &#39;len(mi)=N-1 for a system of N segments.&#39;)

        if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
            # Boundary segements must be on foundation for infinite BCs
            if not all([ki[0], ki[-1]]):
                raise ValueError(&#39;Provide bedded boundary segments in &#39;
                                 &#39;order to account for infinite extensions.&#39;)
            # Make sure infinity boundary conditions are far enough from skiers
            if li[0] &lt; 5e3 or li[-1] &lt; 5e3:
                print((&#39;WARNING: Boundary segments are short. Make sure &#39;
                       &#39;the complementary solution has decayed to the &#39;
                       &#39;boundaries.&#39;))

        # --- PREPROCESSING ---------------------------------------------------

        # Determine size of linear system of equations
        nS = len(li)            # Number of beam segments
        nDOF = 6                # Number of free constants per segment

        # Add dummy segment if only one segment provided
        if nS == 1:
            li.append(0)
            ki.append(True)
            mi.append(0)
            nS = 2

        # Assemble position vector
        pi = np.full(nS, &#39;m&#39;)
        pi[0], pi[-1] = &#39;l&#39;, &#39;r&#39;

        # Initialize matrices
        zh0 = np.zeros([nS*6, nS*nDOF])
        zp0 = np.zeros([nS*6, 1])
        rhs = np.zeros([nS*6, 1])

        # --- ASSEMBLE LINEAR SYSTEM OF EQUATIONS -----------------------------

        # Loop through segments to assemble left-hand side
        for i in range(nS):
            # Length, foundation and position of segment i
            l, k, pos = li[i], ki[i], pi[i]
            # Transmission conditions at left and right segment ends
            zhi = self.eqs(
                zl=self.zh(x=0, l=l, bed=k),
                zr=self.zh(x=l, l=l, bed=k),
                pos=pos)
            zpi = self.eqs(
                zl=self.zp(x=0, phi=phi, bed=k),
                zr=self.zp(x=l, phi=phi, bed=k),
                pos=pos)
            # Rows for left-hand side assembly
            start = 0 if i == 0 else 3
            stop = 6 if i == nS-1 else 9
            # Assemble left-hand side
            zh0[(6*i-start):(6*i+stop), i*nDOF:(i+1)*nDOF] = zhi
            zp0[(6*i-start):(6*i+stop)] += zpi

        # Loop through loads to assemble right-hand side
        for i, m in enumerate(mi, start=1):
            # Get skier loads
            Fn, Ft = self.get_skier_load(m, phi)
            # Right-hand side for transmission from segment i-1 to segment i
            rhs[6*i:6*i+3] = np.vstack([Ft, -Ft*self.h/2, Fn])

        # Set rhs so that complementary integral vanishes at boundaries
        if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
            rhs[:3] = self.bc(self.zp(x=0, phi=phi, bed=ki[0]))
            rhs[-3:] = self.bc(self.zp(x=li[-1], phi=phi, bed=ki[-1]))

        # --- SOLVE -----------------------------------------------------------

        # Solve z0 = zh0*C + zp0 = rhs for constants, i.e. zh0*C = rhs - zp0
        C = np.linalg.solve(zh0, rhs - zp0)

        # Sort (nDOF = 6) constants for each segment into columns of a matrix
        return C.reshape([-1, nDOF]).T


class AnalysisMixin:
    &#34;&#34;&#34;
    Mixin for the analysis of model outputs.

    Provides methods for the analysis of layered slabs on compliant
    elastic foundations.
    &#34;&#34;&#34;

    def rasterize_solution(self, C, phi, li, ki, num=250, **kwargs):
        &#34;&#34;&#34;
        Compute rasterized solution vector.

        Arguments
        ---------
        C : ndarray
            Vector of free constants.
        phi : float
            Inclination (degrees).
        li : ndarray
            List of segment lengths (mm).
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not.
        num : int
            Number of grid points.

        Returns
        -------
        xq : ndarray
            Grid point x-coordinates at which solution vector
            is discretized.
        zq : ndarray
            Matrix with solution vectors as colums at grid
            points xq.
        xb : ndarray
            Grid point x-coordinates that lie on a foundation.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Drop zero-length segments
        isnonzero = li &gt; 0
        C, ki, li = C[:, isnonzero], ki[isnonzero], li[isnonzero]

        # Compute number of plot points per segment (+1 for last segment)
        nq = np.ceil(li/li.sum()*num).astype(&#39;int&#39;)
        nq[-1] += 1

        # Provide cumulated length and plot point lists
        lic = np.insert(np.cumsum(li), 0, 0)
        nqc = np.insert(np.cumsum(nq), 0, 0)

        # Initialize arrays
        isbedded = np.full(nq.sum(), True)
        xq = np.full(nq.sum(), np.nan)
        zq = np.full([6, xq.size], np.nan)

        # Loop through segments
        for i, l in enumerate(li):
            # Get local x-coordinates of segment i
            xi = np.linspace(0, l, num=nq[i], endpoint=(i == li.size - 1))
            # Compute start and end coordinates of segment i
            x0 = lic[i]
            # Assemble global coordinate vector
            xq[nqc[i]:nqc[i+1]] = x0 + xi
            # Mask coordinates not on foundation (excluding endpoints)
            if not ki[i]:
                isbedded[nqc[i]+1:nqc[i+1]] = False
            # Compute segment solution
            zi = self.z(xi, C[:, [i]], l, phi, ki[i])
            # Assemble global solution matrix
            zq[:, nqc[i]:nqc[i+1]] = zi

        # Add masking of consecutive unbedded segments
        isrepeated = [ki[j] or ki[j+1] for j, _ in enumerate(ki[:-1])]
        for i, truefalse in enumerate(isrepeated, start=1):
            isbedded[nqc[i]] = truefalse

        # Assemble vector of coordinates on foundation
        xb = np.full(nq.sum(), np.nan)
        xb[isbedded] = xq[isbedded]

        return xq, zq, xb

    def ginc(self, C0, C1, phi, li, ki, k0, **kwargs):
        &#34;&#34;&#34;
        Compute incremental energy relase rate of of all cracks.

        Arguments
        ---------
        C0 : ndarray
            Free constants of uncracked solution.
        C1 : ndarray
            Free constants of cracked solution.
        phi : float
            Inclination (degress).
        li : ndarray
            List of segment lengths.
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the cracked configuration.
        k0 : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the uncracked configuration.

        Returns
        -------
        ndarray
            List of total, mode I, and mode II energy release rates.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Make sure inputs are np.arrays
        li, ki, k0 = np.array(li), np.array(ki), np.array(k0)

        # Reduce inputs to segments with crack advance
        iscrack = k0 &amp; ~ki
        C0, C1, li = C0[:, iscrack], C1[:, iscrack], li[iscrack]

        # Compute total crack lenght and initialize outputs
        da = li.sum() if li.sum() &gt; 0 else np.nan
        Ginc1, Ginc2 = 0, 0

        # Loop through segments with crack advance
        for j, l in enumerate(li):

            # Uncracked (0) and cracked (1) solutions at integration points
            z0 = partial(self.z, C=C0[:, [j]], l=l, phi=phi, bed=True)
            z1 = partial(self.z, C=C1[:, [j]], l=l, phi=phi, bed=False)

            # Mode I (1) and II (2) integrands at integration points
            int1 = partial(self.int1, z0=z0, z1=z1)
            int2 = partial(self.int2, z0=z0, z1=z1)

            # Segement contributions to total crack opening integral
            Ginc1 += romberg(int1, 0, l, rtol=self.tol, vec_func=True)/(2*da)
            Ginc2 += romberg(int2, 0, l, rtol=self.tol, vec_func=True)/(2*da)

        return np.array([Ginc1 + Ginc2, Ginc1, Ginc2]).flatten()

    def gdif(self, C, phi, li, ki, **kwargs):
        &#34;&#34;&#34;
        Compute differential energy release rate of all crack tips.

        Arguments
        ---------
        C : ndarray
            Free constants of the solution.
        phi : float
            Inclination (degress).
        li : ndarray
            List of segment lengths.
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the cracked configuration.

        Returns
        -------
        ndarray
            List of total, mode I, and mode II energy release rates.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Get number and indices of segment transitions
        ntr = len(li) - 1
        itr = np.arange(ntr)

        # Identify bedded-free and free-bedded transitions as crack tips
        iscracktip = [ki[j] != ki[j+1] for j in range(ntr)]

        # Transition indices of crack tips and total number of crack tips
        ict = itr[iscracktip]
        nct = len(ict)

        # Initialize energy release rate array
        Gdif = np.zeros([3, nct])

        # Compute energy relase rate of all crack tips
        for j, idx in enumerate(ict):
            # Solution at crack tip
            z = self.z(li[idx], C[:, [idx]], li[idx], phi, bed=ki[idx])
            # Mode I and II differential energy release rates
            Gdif[1:, j] = self.Gi(z), self.Gii(z)

        # Sum mode I and II contributions
        Gdif[0, :] = Gdif[1, :] + Gdif[2, :]

        # Adjust contributions for center cracks
        avgmask = np.full(nct, True)        # Initialize mask
        avgmask[[0, -1]] = ki[[0, -1]]      # Do not weight edge cracks
        Gdif[:, avgmask] *= 0.5             # Weigth with half crack length

        # Return total differential energy release rate of all crack tips
        return Gdif.sum(axis=1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weac.mixins.AnalysisMixin"><code class="flex name class">
<span>class <span class="ident">AnalysisMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for the analysis of model outputs.</p>
<p>Provides methods for the analysis of layered slabs on compliant
elastic foundations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalysisMixin:
    &#34;&#34;&#34;
    Mixin for the analysis of model outputs.

    Provides methods for the analysis of layered slabs on compliant
    elastic foundations.
    &#34;&#34;&#34;

    def rasterize_solution(self, C, phi, li, ki, num=250, **kwargs):
        &#34;&#34;&#34;
        Compute rasterized solution vector.

        Arguments
        ---------
        C : ndarray
            Vector of free constants.
        phi : float
            Inclination (degrees).
        li : ndarray
            List of segment lengths (mm).
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not.
        num : int
            Number of grid points.

        Returns
        -------
        xq : ndarray
            Grid point x-coordinates at which solution vector
            is discretized.
        zq : ndarray
            Matrix with solution vectors as colums at grid
            points xq.
        xb : ndarray
            Grid point x-coordinates that lie on a foundation.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Drop zero-length segments
        isnonzero = li &gt; 0
        C, ki, li = C[:, isnonzero], ki[isnonzero], li[isnonzero]

        # Compute number of plot points per segment (+1 for last segment)
        nq = np.ceil(li/li.sum()*num).astype(&#39;int&#39;)
        nq[-1] += 1

        # Provide cumulated length and plot point lists
        lic = np.insert(np.cumsum(li), 0, 0)
        nqc = np.insert(np.cumsum(nq), 0, 0)

        # Initialize arrays
        isbedded = np.full(nq.sum(), True)
        xq = np.full(nq.sum(), np.nan)
        zq = np.full([6, xq.size], np.nan)

        # Loop through segments
        for i, l in enumerate(li):
            # Get local x-coordinates of segment i
            xi = np.linspace(0, l, num=nq[i], endpoint=(i == li.size - 1))
            # Compute start and end coordinates of segment i
            x0 = lic[i]
            # Assemble global coordinate vector
            xq[nqc[i]:nqc[i+1]] = x0 + xi
            # Mask coordinates not on foundation (excluding endpoints)
            if not ki[i]:
                isbedded[nqc[i]+1:nqc[i+1]] = False
            # Compute segment solution
            zi = self.z(xi, C[:, [i]], l, phi, ki[i])
            # Assemble global solution matrix
            zq[:, nqc[i]:nqc[i+1]] = zi

        # Add masking of consecutive unbedded segments
        isrepeated = [ki[j] or ki[j+1] for j, _ in enumerate(ki[:-1])]
        for i, truefalse in enumerate(isrepeated, start=1):
            isbedded[nqc[i]] = truefalse

        # Assemble vector of coordinates on foundation
        xb = np.full(nq.sum(), np.nan)
        xb[isbedded] = xq[isbedded]

        return xq, zq, xb

    def ginc(self, C0, C1, phi, li, ki, k0, **kwargs):
        &#34;&#34;&#34;
        Compute incremental energy relase rate of of all cracks.

        Arguments
        ---------
        C0 : ndarray
            Free constants of uncracked solution.
        C1 : ndarray
            Free constants of cracked solution.
        phi : float
            Inclination (degress).
        li : ndarray
            List of segment lengths.
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the cracked configuration.
        k0 : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the uncracked configuration.

        Returns
        -------
        ndarray
            List of total, mode I, and mode II energy release rates.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Make sure inputs are np.arrays
        li, ki, k0 = np.array(li), np.array(ki), np.array(k0)

        # Reduce inputs to segments with crack advance
        iscrack = k0 &amp; ~ki
        C0, C1, li = C0[:, iscrack], C1[:, iscrack], li[iscrack]

        # Compute total crack lenght and initialize outputs
        da = li.sum() if li.sum() &gt; 0 else np.nan
        Ginc1, Ginc2 = 0, 0

        # Loop through segments with crack advance
        for j, l in enumerate(li):

            # Uncracked (0) and cracked (1) solutions at integration points
            z0 = partial(self.z, C=C0[:, [j]], l=l, phi=phi, bed=True)
            z1 = partial(self.z, C=C1[:, [j]], l=l, phi=phi, bed=False)

            # Mode I (1) and II (2) integrands at integration points
            int1 = partial(self.int1, z0=z0, z1=z1)
            int2 = partial(self.int2, z0=z0, z1=z1)

            # Segement contributions to total crack opening integral
            Ginc1 += romberg(int1, 0, l, rtol=self.tol, vec_func=True)/(2*da)
            Ginc2 += romberg(int2, 0, l, rtol=self.tol, vec_func=True)/(2*da)

        return np.array([Ginc1 + Ginc2, Ginc1, Ginc2]).flatten()

    def gdif(self, C, phi, li, ki, **kwargs):
        &#34;&#34;&#34;
        Compute differential energy release rate of all crack tips.

        Arguments
        ---------
        C : ndarray
            Free constants of the solution.
        phi : float
            Inclination (degress).
        li : ndarray
            List of segment lengths.
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the cracked configuration.

        Returns
        -------
        ndarray
            List of total, mode I, and mode II energy release rates.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Get number and indices of segment transitions
        ntr = len(li) - 1
        itr = np.arange(ntr)

        # Identify bedded-free and free-bedded transitions as crack tips
        iscracktip = [ki[j] != ki[j+1] for j in range(ntr)]

        # Transition indices of crack tips and total number of crack tips
        ict = itr[iscracktip]
        nct = len(ict)

        # Initialize energy release rate array
        Gdif = np.zeros([3, nct])

        # Compute energy relase rate of all crack tips
        for j, idx in enumerate(ict):
            # Solution at crack tip
            z = self.z(li[idx], C[:, [idx]], li[idx], phi, bed=ki[idx])
            # Mode I and II differential energy release rates
            Gdif[1:, j] = self.Gi(z), self.Gii(z)

        # Sum mode I and II contributions
        Gdif[0, :] = Gdif[1, :] + Gdif[2, :]

        # Adjust contributions for center cracks
        avgmask = np.full(nct, True)        # Initialize mask
        avgmask[[0, -1]] = ki[[0, -1]]      # Do not weight edge cracks
        Gdif[:, avgmask] *= 0.5             # Weigth with half crack length

        # Return total differential energy release rate of all crack tips
        return Gdif.sum(axis=1)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weac.inverse.Inverse" href="inverse.html#weac.inverse.Inverse">Inverse</a></li>
<li><a title="weac.layered.Layered" href="layered.html#weac.layered.Layered">Layered</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="weac.mixins.AnalysisMixin.gdif"><code class="name flex">
<span>def <span class="ident">gdif</span></span>(<span>self, C, phi, li, ki, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute differential energy release rate of all crack tips.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Free constants of the solution.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degress).</dd>
<dt><strong><code>li</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of segment lengths.</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of booleans indicating whether segment lies on
a foundation or not in the cracked configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>List of total, mode I, and mode II energy release rates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gdif(self, C, phi, li, ki, **kwargs):
    &#34;&#34;&#34;
    Compute differential energy release rate of all crack tips.

    Arguments
    ---------
    C : ndarray
        Free constants of the solution.
    phi : float
        Inclination (degress).
    li : ndarray
        List of segment lengths.
    ki : ndarray
        List of booleans indicating whether segment lies on
        a foundation or not in the cracked configuration.

    Returns
    -------
    ndarray
        List of total, mode I, and mode II energy release rates.
    &#34;&#34;&#34;
    # Unused arguments
    _ = kwargs

    # Get number and indices of segment transitions
    ntr = len(li) - 1
    itr = np.arange(ntr)

    # Identify bedded-free and free-bedded transitions as crack tips
    iscracktip = [ki[j] != ki[j+1] for j in range(ntr)]

    # Transition indices of crack tips and total number of crack tips
    ict = itr[iscracktip]
    nct = len(ict)

    # Initialize energy release rate array
    Gdif = np.zeros([3, nct])

    # Compute energy relase rate of all crack tips
    for j, idx in enumerate(ict):
        # Solution at crack tip
        z = self.z(li[idx], C[:, [idx]], li[idx], phi, bed=ki[idx])
        # Mode I and II differential energy release rates
        Gdif[1:, j] = self.Gi(z), self.Gii(z)

    # Sum mode I and II contributions
    Gdif[0, :] = Gdif[1, :] + Gdif[2, :]

    # Adjust contributions for center cracks
    avgmask = np.full(nct, True)        # Initialize mask
    avgmask[[0, -1]] = ki[[0, -1]]      # Do not weight edge cracks
    Gdif[:, avgmask] *= 0.5             # Weigth with half crack length

    # Return total differential energy release rate of all crack tips
    return Gdif.sum(axis=1)</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.ginc"><code class="name flex">
<span>def <span class="ident">ginc</span></span>(<span>self, C0, C1, phi, li, ki, k0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute incremental energy relase rate of of all cracks.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>C0</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Free constants of uncracked solution.</dd>
<dt><strong><code>C1</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Free constants of cracked solution.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degress).</dd>
<dt><strong><code>li</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of segment lengths.</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of booleans indicating whether segment lies on
a foundation or not in the cracked configuration.</dd>
<dt><strong><code>k0</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of booleans indicating whether segment lies on
a foundation or not in the uncracked configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>List of total, mode I, and mode II energy release rates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ginc(self, C0, C1, phi, li, ki, k0, **kwargs):
    &#34;&#34;&#34;
    Compute incremental energy relase rate of of all cracks.

    Arguments
    ---------
    C0 : ndarray
        Free constants of uncracked solution.
    C1 : ndarray
        Free constants of cracked solution.
    phi : float
        Inclination (degress).
    li : ndarray
        List of segment lengths.
    ki : ndarray
        List of booleans indicating whether segment lies on
        a foundation or not in the cracked configuration.
    k0 : ndarray
        List of booleans indicating whether segment lies on
        a foundation or not in the uncracked configuration.

    Returns
    -------
    ndarray
        List of total, mode I, and mode II energy release rates.
    &#34;&#34;&#34;
    # Unused arguments
    _ = kwargs

    # Make sure inputs are np.arrays
    li, ki, k0 = np.array(li), np.array(ki), np.array(k0)

    # Reduce inputs to segments with crack advance
    iscrack = k0 &amp; ~ki
    C0, C1, li = C0[:, iscrack], C1[:, iscrack], li[iscrack]

    # Compute total crack lenght and initialize outputs
    da = li.sum() if li.sum() &gt; 0 else np.nan
    Ginc1, Ginc2 = 0, 0

    # Loop through segments with crack advance
    for j, l in enumerate(li):

        # Uncracked (0) and cracked (1) solutions at integration points
        z0 = partial(self.z, C=C0[:, [j]], l=l, phi=phi, bed=True)
        z1 = partial(self.z, C=C1[:, [j]], l=l, phi=phi, bed=False)

        # Mode I (1) and II (2) integrands at integration points
        int1 = partial(self.int1, z0=z0, z1=z1)
        int2 = partial(self.int2, z0=z0, z1=z1)

        # Segement contributions to total crack opening integral
        Ginc1 += romberg(int1, 0, l, rtol=self.tol, vec_func=True)/(2*da)
        Ginc2 += romberg(int2, 0, l, rtol=self.tol, vec_func=True)/(2*da)

    return np.array([Ginc1 + Ginc2, Ginc1, Ginc2]).flatten()</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.rasterize_solution"><code class="name flex">
<span>def <span class="ident">rasterize_solution</span></span>(<span>self, C, phi, li, ki, num=250, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute rasterized solution vector.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Vector of free constants.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees).</dd>
<dt><strong><code>li</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of segment lengths (mm).</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of booleans indicating whether segment lies on
a foundation or not.</dd>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of grid points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xq</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Grid point x-coordinates at which solution vector
is discretized.</dd>
<dt><strong><code>zq</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix with solution vectors as colums at grid
points xq.</dd>
<dt><strong><code>xb</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Grid point x-coordinates that lie on a foundation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rasterize_solution(self, C, phi, li, ki, num=250, **kwargs):
    &#34;&#34;&#34;
    Compute rasterized solution vector.

    Arguments
    ---------
    C : ndarray
        Vector of free constants.
    phi : float
        Inclination (degrees).
    li : ndarray
        List of segment lengths (mm).
    ki : ndarray
        List of booleans indicating whether segment lies on
        a foundation or not.
    num : int
        Number of grid points.

    Returns
    -------
    xq : ndarray
        Grid point x-coordinates at which solution vector
        is discretized.
    zq : ndarray
        Matrix with solution vectors as colums at grid
        points xq.
    xb : ndarray
        Grid point x-coordinates that lie on a foundation.
    &#34;&#34;&#34;
    # Unused arguments
    _ = kwargs

    # Drop zero-length segments
    isnonzero = li &gt; 0
    C, ki, li = C[:, isnonzero], ki[isnonzero], li[isnonzero]

    # Compute number of plot points per segment (+1 for last segment)
    nq = np.ceil(li/li.sum()*num).astype(&#39;int&#39;)
    nq[-1] += 1

    # Provide cumulated length and plot point lists
    lic = np.insert(np.cumsum(li), 0, 0)
    nqc = np.insert(np.cumsum(nq), 0, 0)

    # Initialize arrays
    isbedded = np.full(nq.sum(), True)
    xq = np.full(nq.sum(), np.nan)
    zq = np.full([6, xq.size], np.nan)

    # Loop through segments
    for i, l in enumerate(li):
        # Get local x-coordinates of segment i
        xi = np.linspace(0, l, num=nq[i], endpoint=(i == li.size - 1))
        # Compute start and end coordinates of segment i
        x0 = lic[i]
        # Assemble global coordinate vector
        xq[nqc[i]:nqc[i+1]] = x0 + xi
        # Mask coordinates not on foundation (excluding endpoints)
        if not ki[i]:
            isbedded[nqc[i]+1:nqc[i+1]] = False
        # Compute segment solution
        zi = self.z(xi, C[:, [i]], l, phi, ki[i])
        # Assemble global solution matrix
        zq[:, nqc[i]:nqc[i+1]] = zi

    # Add masking of consecutive unbedded segments
    isrepeated = [ki[j] or ki[j+1] for j, _ in enumerate(ki[:-1])]
    for i, truefalse in enumerate(isrepeated, start=1):
        isbedded[nqc[i]] = truefalse

    # Assemble vector of coordinates on foundation
    xb = np.full(nq.sum(), np.nan)
    xb[isbedded] = xq[isbedded]

    return xq, zq, xb</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin"><code class="flex name class">
<span>class <span class="ident">FieldQuantitiesMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for field quantities.</p>
<p>Provides methods for the computation of displacements, stresses,
strains, and energy release rates from the solution vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldQuantitiesMixin:
    &#34;&#34;&#34;
    Mixin for field quantities.

    Provides methods for the computation of displacements, stresses,
    strains, and energy release rates from the solution vector.
    &#34;&#34;&#34;

    # pylint: disable=no-self-use
    def w(self, Z):
        &#34;&#34;&#34;
        Get centerline deflection w.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        w : float
            Deflection w (mm) of the slab.
        &#34;&#34;&#34;
        return Z[2, :]

    def wp(self, Z):
        &#34;&#34;&#34;
        Get first derivative w&#39; of the centerline deflection.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        wp : float
            First derivative w&#39; of the deflection of the slab.
        &#34;&#34;&#34;
        return Z[3, :]

    def psi(self, Z):
        &#34;&#34;&#34;
        Get midplane rotation psi.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        psi : float
            Midplane rotation psi (radians) of the slab.
        &#34;&#34;&#34;
        return Z[4, :]

    def psip(self, Z):
        &#34;&#34;&#34;
        Get first derivative psi&#39; of the midplane rotation.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        psip : float
            First derivative psi&#39; of the midplane rotation (radians/mm)
             of the slab.
        &#34;&#34;&#34;
        return Z[5, :]

    # pylint: enable=no-self-use
    def u(self, Z, z0):
        &#34;&#34;&#34;
        Get horizontal displacement u = u0 + z0 psi.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        z0 : float
            Z-coordinate (mm) where u is to be evaluated.

        Returns
        -------
        u : float
            Horizontal displacement u (mm) of the slab.
        &#34;&#34;&#34;
        return Z[0, :] + z0*self.psi(Z)

    def up(self, Z, z0):
        &#34;&#34;&#34;
        Get first derivative of the horizontal displacement.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        z0 : float
            Z-coordinate (mm) where u is to be evaluated.

        Returns
        -------
        up : float
            First derivative u&#39; = u0&#39; + z0 psi&#39; of the horizontal
            displacement of the slab.
        &#34;&#34;&#34;
        return Z[1, :] + z0*self.psip(Z)

    def N(self, Z):
        &#34;&#34;&#34;
        Get the axial normal force N = A11 u&#39; + B11 psi&#39; in the slab.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        N : float
            Axial normal force N (N) in the slab.
        &#34;&#34;&#34;
        return self.A11*Z[1, :] + self.B11*Z[5, :]

    def M(self, Z):
        &#34;&#34;&#34;
        Get bending moment M = B11 u&#39; + D11 psi&#39; in the slab.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        M : float
            Bending moment M (Nmm) in the slab.
        &#34;&#34;&#34;
        return self.B11*Z[1, :] + self.D11*Z[5, :]

    def V(self, Z):
        &#34;&#34;&#34;
        Get vertical shear force V = kA55(w&#39; + psi).

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        V : float
            Vertical shear force V (N) in the slab.
        &#34;&#34;&#34;
        return self.kA55*(Z[3, :] + Z[4, :])

    def sig(self, Z):
        &#34;&#34;&#34;
        Get weak-layer normal stress.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        sig : float
            Weak-layer normal stress sigma (MPa).
        &#34;&#34;&#34;
        return -self.kn*self.w(Z)

    def tau(self, Z):
        &#34;&#34;&#34;
        Get weak-layer shear stress.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        tau : float
            Weak-layer shear stress tau (MPa).
        &#34;&#34;&#34;
        return self.kt*(self.wp(Z)*self.t/2 - self.u(Z, z0=self.h/2))

    def eps(self, Z):
        &#34;&#34;&#34;
        Get weak-layer normal strain.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        eps : float
            Weak-layer normal strain epsilon (MPa).
        &#34;&#34;&#34;
        return -self.w(Z)/self.t

    def gamma(self, Z):
        &#34;&#34;&#34;
        Get weak-layer shear strain.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        gamma : float
            Weak-layer shear strain gamma (MPa).
        &#34;&#34;&#34;
        return self.wp(Z)/2 - self.u(Z, z0=self.h/2)/self.t

    def maxp(self, Z):
        &#34;&#34;&#34;
        Get maximum principal stress in the weak layer.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        maxp : float
            Maximum principal stress (MPa) in the weak layer.
        &#34;&#34;&#34;
        sig = self.sig(Z)
        tau = self.tau(Z)
        return np.amax([[sig + np.sqrt(sig**2 + 4*tau**2),
                         sig - np.sqrt(sig**2 + 4*tau**2)]], axis=1)[0]/2

    def Gi(self, Ztip):
        &#34;&#34;&#34;
        Get mode I differential energy release rate at crack tip.

        Arguments
        ---------
        Ztip : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
            at the crack tip.

        Returns
        -------
        Gi : float
            Mode I differential energy release rate (N/mm) at the
            crack tip.
        &#34;&#34;&#34;
        return self.sig(Ztip)**2/(2*self.kn)

    def Gii(self, Ztip):
        &#34;&#34;&#34;
        Get mode II differential energy release rate at crack tip.

        Arguments
        ---------
        Ztip : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
            at the crack tip.

        Returns
        -------
        Gii : float
            Mode II differential energy release rate (N/mm) at the
            crack tip.
        &#34;&#34;&#34;
        return self.tau(Ztip)**2/(2*self.kt)

    def int1(self, x, z0, z1):
        &#34;&#34;&#34;
        Get mode I crack opening integrand at integration points xi.

        Arguments
        ---------
        x : float, ndarray
            X-coordinate where integrand is to be evaluated (mm).
        z0 : callable
            Function that returns the solution vector of the uncracked
            configuration.
        z1 : callable
            Function that returns the solution vector of the cracked
            configuration.

        Returns
        -------
        int1 : float or ndarray
            Integrant of the mode I crack opening integral.
        &#34;&#34;&#34;
        return self.sig(z0(x))*self.eps(z1(x))*self.t

    def int2(self, x, z0, z1):
        &#34;&#34;&#34;
        Get mode II crack opening integrand at integration points xi.

        Arguments
        ---------
        x: float, ndarray
            X-coordinate where integrand is to be evaluated(mm).
        z0: callable
            Function that returns the solution vector of the uncracked
            configuration.
        z1: callable
            Function that returns the solution vector of the cracked
            configuration.

        Returns
        -------
        int2 : float or ndarray
            Integrant of the mode II crack opening integral.
        &#34;&#34;&#34;
        return self.tau(z0(x))*self.gamma(z1(x))*self.t</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weac.inverse.Inverse" href="inverse.html#weac.inverse.Inverse">Inverse</a></li>
<li><a title="weac.layered.Layered" href="layered.html#weac.layered.Layered">Layered</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="weac.mixins.FieldQuantitiesMixin.Gi"><code class="name flex">
<span>def <span class="ident">Gi</span></span>(<span>self, Ztip)</span>
</code></dt>
<dd>
<div class="desc"><p>Get mode I differential energy release rate at crack tip.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Ztip</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T
at the crack tip.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Gi</code></strong> :&ensp;<code>float</code></dt>
<dd>Mode I differential energy release rate (N/mm) at the
crack tip.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Gi(self, Ztip):
    &#34;&#34;&#34;
    Get mode I differential energy release rate at crack tip.

    Arguments
    ---------
    Ztip : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
        at the crack tip.

    Returns
    -------
    Gi : float
        Mode I differential energy release rate (N/mm) at the
        crack tip.
    &#34;&#34;&#34;
    return self.sig(Ztip)**2/(2*self.kn)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.Gii"><code class="name flex">
<span>def <span class="ident">Gii</span></span>(<span>self, Ztip)</span>
</code></dt>
<dd>
<div class="desc"><p>Get mode II differential energy release rate at crack tip.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Ztip</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T
at the crack tip.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Gii</code></strong> :&ensp;<code>float</code></dt>
<dd>Mode II differential energy release rate (N/mm) at the
crack tip.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Gii(self, Ztip):
    &#34;&#34;&#34;
    Get mode II differential energy release rate at crack tip.

    Arguments
    ---------
    Ztip : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
        at the crack tip.

    Returns
    -------
    Gii : float
        Mode II differential energy release rate (N/mm) at the
        crack tip.
    &#34;&#34;&#34;
    return self.tau(Ztip)**2/(2*self.kt)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.M"><code class="name flex">
<span>def <span class="ident">M</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get bending moment M = B11 u' + D11 psi' in the slab.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>M</code></strong> :&ensp;<code>float</code></dt>
<dd>Bending moment M (Nmm) in the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def M(self, Z):
    &#34;&#34;&#34;
    Get bending moment M = B11 u&#39; + D11 psi&#39; in the slab.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    M : float
        Bending moment M (Nmm) in the slab.
    &#34;&#34;&#34;
    return self.B11*Z[1, :] + self.D11*Z[5, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.N"><code class="name flex">
<span>def <span class="ident">N</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the axial normal force N = A11 u' + B11 psi' in the slab.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>float</code></dt>
<dd>Axial normal force N (N) in the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def N(self, Z):
    &#34;&#34;&#34;
    Get the axial normal force N = A11 u&#39; + B11 psi&#39; in the slab.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    N : float
        Axial normal force N (N) in the slab.
    &#34;&#34;&#34;
    return self.A11*Z[1, :] + self.B11*Z[5, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.V"><code class="name flex">
<span>def <span class="ident">V</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get vertical shear force V = kA55(w' + psi).</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>float</code></dt>
<dd>Vertical shear force V (N) in the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V(self, Z):
    &#34;&#34;&#34;
    Get vertical shear force V = kA55(w&#39; + psi).

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    V : float
        Vertical shear force V (N) in the slab.
    &#34;&#34;&#34;
    return self.kA55*(Z[3, :] + Z[4, :])</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.eps"><code class="name flex">
<span>def <span class="ident">eps</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get weak-layer normal strain.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code></dt>
<dd>Weak-layer normal strain epsilon (MPa).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eps(self, Z):
    &#34;&#34;&#34;
    Get weak-layer normal strain.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    eps : float
        Weak-layer normal strain epsilon (MPa).
    &#34;&#34;&#34;
    return -self.w(Z)/self.t</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.gamma"><code class="name flex">
<span>def <span class="ident">gamma</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get weak-layer shear strain.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Weak-layer shear strain gamma (MPa).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gamma(self, Z):
    &#34;&#34;&#34;
    Get weak-layer shear strain.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    gamma : float
        Weak-layer shear strain gamma (MPa).
    &#34;&#34;&#34;
    return self.wp(Z)/2 - self.u(Z, z0=self.h/2)/self.t</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.int1"><code class="name flex">
<span>def <span class="ident">int1</span></span>(<span>self, x, z0, z1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get mode I crack opening integrand at integration points xi.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float, ndarray</code></dt>
<dd>X-coordinate where integrand is to be evaluated (mm).</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function that returns the solution vector of the uncracked
configuration.</dd>
<dt><strong><code>z1</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function that returns the solution vector of the cracked
configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int1</code></strong> :&ensp;<code>float</code> or <code>ndarray</code></dt>
<dd>Integrant of the mode I crack opening integral.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int1(self, x, z0, z1):
    &#34;&#34;&#34;
    Get mode I crack opening integrand at integration points xi.

    Arguments
    ---------
    x : float, ndarray
        X-coordinate where integrand is to be evaluated (mm).
    z0 : callable
        Function that returns the solution vector of the uncracked
        configuration.
    z1 : callable
        Function that returns the solution vector of the cracked
        configuration.

    Returns
    -------
    int1 : float or ndarray
        Integrant of the mode I crack opening integral.
    &#34;&#34;&#34;
    return self.sig(z0(x))*self.eps(z1(x))*self.t</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.int2"><code class="name flex">
<span>def <span class="ident">int2</span></span>(<span>self, x, z0, z1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get mode II crack opening integrand at integration points xi.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float, ndarray</code></dt>
<dd>X-coordinate where integrand is to be evaluated(mm).</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function that returns the solution vector of the uncracked
configuration.</dd>
<dt><strong><code>z1</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function that returns the solution vector of the cracked
configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int2</code></strong> :&ensp;<code>float</code> or <code>ndarray</code></dt>
<dd>Integrant of the mode II crack opening integral.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int2(self, x, z0, z1):
    &#34;&#34;&#34;
    Get mode II crack opening integrand at integration points xi.

    Arguments
    ---------
    x: float, ndarray
        X-coordinate where integrand is to be evaluated(mm).
    z0: callable
        Function that returns the solution vector of the uncracked
        configuration.
    z1: callable
        Function that returns the solution vector of the cracked
        configuration.

    Returns
    -------
    int2 : float or ndarray
        Integrant of the mode II crack opening integral.
    &#34;&#34;&#34;
    return self.tau(z0(x))*self.gamma(z1(x))*self.t</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.maxp"><code class="name flex">
<span>def <span class="ident">maxp</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get maximum principal stress in the weak layer.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>maxp</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum principal stress (MPa) in the weak layer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxp(self, Z):
    &#34;&#34;&#34;
    Get maximum principal stress in the weak layer.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    maxp : float
        Maximum principal stress (MPa) in the weak layer.
    &#34;&#34;&#34;
    sig = self.sig(Z)
    tau = self.tau(Z)
    return np.amax([[sig + np.sqrt(sig**2 + 4*tau**2),
                     sig - np.sqrt(sig**2 + 4*tau**2)]], axis=1)[0]/2</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.psi"><code class="name flex">
<span>def <span class="ident">psi</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get midplane rotation psi.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psi</code></strong> :&ensp;<code>float</code></dt>
<dd>Midplane rotation psi (radians) of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def psi(self, Z):
    &#34;&#34;&#34;
    Get midplane rotation psi.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    psi : float
        Midplane rotation psi (radians) of the slab.
    &#34;&#34;&#34;
    return Z[4, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.psip"><code class="name flex">
<span>def <span class="ident">psip</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get first derivative psi' of the midplane rotation.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psip</code></strong> :&ensp;<code>float</code></dt>
<dd>First derivative psi' of the midplane rotation (radians/mm)
of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def psip(self, Z):
    &#34;&#34;&#34;
    Get first derivative psi&#39; of the midplane rotation.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    psip : float
        First derivative psi&#39; of the midplane rotation (radians/mm)
         of the slab.
    &#34;&#34;&#34;
    return Z[5, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.sig"><code class="name flex">
<span>def <span class="ident">sig</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get weak-layer normal stress.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sig</code></strong> :&ensp;<code>float</code></dt>
<dd>Weak-layer normal stress sigma (MPa).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sig(self, Z):
    &#34;&#34;&#34;
    Get weak-layer normal stress.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    sig : float
        Weak-layer normal stress sigma (MPa).
    &#34;&#34;&#34;
    return -self.kn*self.w(Z)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.tau"><code class="name flex">
<span>def <span class="ident">tau</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get weak-layer shear stress.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tau</code></strong> :&ensp;<code>float</code></dt>
<dd>Weak-layer shear stress tau (MPa).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tau(self, Z):
    &#34;&#34;&#34;
    Get weak-layer shear stress.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    tau : float
        Weak-layer shear stress tau (MPa).
    &#34;&#34;&#34;
    return self.kt*(self.wp(Z)*self.t/2 - self.u(Z, z0=self.h/2))</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.u"><code class="name flex">
<span>def <span class="ident">u</span></span>(<span>self, Z, z0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get horizontal displacement u = u0 + z0 psi.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>float</code></dt>
<dd>Z-coordinate (mm) where u is to be evaluated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>float</code></dt>
<dd>Horizontal displacement u (mm) of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def u(self, Z, z0):
    &#34;&#34;&#34;
    Get horizontal displacement u = u0 + z0 psi.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    z0 : float
        Z-coordinate (mm) where u is to be evaluated.

    Returns
    -------
    u : float
        Horizontal displacement u (mm) of the slab.
    &#34;&#34;&#34;
    return Z[0, :] + z0*self.psi(Z)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.up"><code class="name flex">
<span>def <span class="ident">up</span></span>(<span>self, Z, z0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get first derivative of the horizontal displacement.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>float</code></dt>
<dd>Z-coordinate (mm) where u is to be evaluated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>up</code></strong> :&ensp;<code>float</code></dt>
<dd>First derivative u' = u0' + z0 psi' of the horizontal
displacement of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def up(self, Z, z0):
    &#34;&#34;&#34;
    Get first derivative of the horizontal displacement.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    z0 : float
        Z-coordinate (mm) where u is to be evaluated.

    Returns
    -------
    up : float
        First derivative u&#39; = u0&#39; + z0 psi&#39; of the horizontal
        displacement of the slab.
    &#34;&#34;&#34;
    return Z[1, :] + z0*self.psip(Z)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.w"><code class="name flex">
<span>def <span class="ident">w</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get centerline deflection w.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>Deflection w (mm) of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def w(self, Z):
    &#34;&#34;&#34;
    Get centerline deflection w.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    w : float
        Deflection w (mm) of the slab.
    &#34;&#34;&#34;
    return Z[2, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.wp"><code class="name flex">
<span>def <span class="ident">wp</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get first derivative w' of the centerline deflection.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>wp</code></strong> :&ensp;<code>float</code></dt>
<dd>First derivative w' of the deflection of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wp(self, Z):
    &#34;&#34;&#34;
    Get first derivative w&#39; of the centerline deflection.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    wp : float
        First derivative w&#39; of the deflection of the slab.
    &#34;&#34;&#34;
    return Z[3, :]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="weac.mixins.SolutionMixin"><code class="flex name class">
<span>class <span class="ident">SolutionMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for the solution of boundary value problems.</p>
<p>Provides methods for the assembly of the system of equations
and for the computation of the free constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SolutionMixin:
    &#34;&#34;&#34;
    Mixin for the solution of boundary value problems.

    Provides methods for the assembly of the system of equations
    and for the computation of the free constants.
    &#34;&#34;&#34;

    def bc(self, z):
        &#34;&#34;&#34;
        Provide equations for free(pst) or infinite(skiers) ends.

        Arguments
        ---------
        z: ndarray
            Solution vector(6x1) at a certain position x.

        Returns
        -------
        bc: ndarray
            Boundary condition vector(lenght 3) at position x.
        &#34;&#34;&#34;
        if self.system in [&#39;pst-&#39;, &#39;-pst&#39;]:
            # Free ends
            bc = np.array([self.N(z), self.M(z), self.V(z)])
        elif self.system in [&#39;skier&#39;, &#39;skiers&#39;]:
            # Infinite ends (vanishing complementary solution)
            bc = np.array([self.u(z, z0=0), self.w(z), self.psi(z)])
        else:
            raise ValueError(
                &#39;Boundary conditions not defined for&#39;
                f&#39;system of type {self.system}.&#39;)

        return bc

    def eqs(self, zl, zr, pos=&#39;mid&#39;):
        &#34;&#34;&#34;
        Provide boundary or transmission conditions for beam segments.

        Arguments
        ---------
        zl: ndarray
            Solution vector(6x1) at left end of beam segement.
        zr: ndarray
            Solution vector(6x1) at right end of beam segement.
        pos: {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
            Determines whether the segement under consideration
            is a left boundary segement(left, l), one of the
            center segement(mid, m), or a right boundary
            segement(right, r). Default is &#39;mid&#39;.

        Returns
        -------
        eqs: ndarray
            Vector(of length 9) of boundary conditions(3) and
            transmission conditions(6) for boundary segements
            or vector of transmission conditions(of length 6+6)
            for center segments.
        &#34;&#34;&#34;
        if pos in (&#39;l&#39;, &#39;left&#39;):
            eqs = np.array([
                self.bc(zl)[0],             # Left boundary condition
                self.bc(zl)[1],             # Left boundary condition
                self.bc(zl)[2],             # Left boundary condition
                self.u(zr, z0=0),           # ui(xi = li)
                self.w(zr),                 # wi(xi = li)
                self.psi(zr),               # psii(xi = li)
                self.N(zr),                 # Ni(xi = li)
                self.M(zr),                 # Mi(xi = li)
                self.V(zr)])                # Vi(xi = li)
        elif pos in (&#39;m&#39;, &#39;mid&#39;):
            eqs = np.array([
                -self.u(zl, z0=0),          # -ui(xi = 0)
                -self.w(zl),                # -wi(xi = 0)
                -self.psi(zl),              # -psii(xi = 0)
                -self.N(zl),                # -Ni(xi = 0)
                -self.M(zl),                # -Mi(xi = 0)
                -self.V(zl),                # -Vi(xi = 0)
                self.u(zr, z0=0),           # ui(xi = li)
                self.w(zr),                 # wi(xi = li)
                self.psi(zr),               # psii(xi = li)
                self.N(zr),                 # Ni(xi = li)
                self.M(zr),                 # Mi(xi = li)
                self.V(zr)])                # Vi(xi = li)
        elif pos in (&#39;r&#39;, &#39;right&#39;):
            eqs = np.array([
                -self.u(zl, z0=0),          # -ui(xi = 0)
                -self.w(zl),                # -wi(xi = 0)
                -self.psi(zl),              # -psii(xi = 0)
                -self.N(zl),                # -Ni(xi = 0)
                -self.M(zl),                # -Mi(xi = 0)
                -self.V(zl),                # -Vi(xi = 0)
                self.bc(zr)[0],             # Right boundary condition
                self.bc(zr)[1],             # Right boundary condition
                self.bc(zr)[2]])            # Right boundary condition
        else:
            raise ValueError(
                (f&#39;Invalid position argument {pos} given. &#39;
                 &#39;Valid segment positions are l, m, and r, &#39;
                 &#39;or left, mid and right.&#39;))

        return eqs

    def calc_segments(self, li=False, mi=False, ki=False, k0=False,
                      L=1e4, a=0, m=0, **kwargs):
        &#34;&#34;&#34;
        Assemble lists defining the segments.

        This includes length(li), foundation(ki, k0), and skier weight(mi).

        Arguments
        ---------
        li: squence, optional
            List of lengths of segements(mm). Used for system &#39;skiers&#39;.
        mi: squence, optional
            List of skier weigths(kg) at segement boundaries. Used for
            system &#39;skiers&#39;.
        ki: squence, optional
            List of one bool per segement indicating whether segement
            has foundation(True) or not (False) in the cracked state.
            Used for system &#39;skiers&#39;.
        k0: squence, optional
            List of one bool per segement indicating whether segement
            has foundation(True) or not (False) in the uncracked state.
            Used for system &#39;skiers&#39;.
        L: float, optional
            Total length of model(mm). Used for systems &#39;pst-&#39;, &#39;-pst&#39;,
            and &#39;skier&#39;.
        a: float, optional
            Crack length(mm).  Used for systems &#39;pst-&#39;, &#39;-pst&#39;, and
            &#39;skier&#39;.
        m: float, optional
            Weight of skier(kg) in the axial center of the model.
            Used for system &#39;skier&#39;.

        Returns
        -------
        segments: dict
            Dictionary with lists of segement lengths(li), skier
            weights(mi), and foundation booleans in the cracked(ki)
            and ncracked(k0) configurations.
        &#34;&#34;&#34;
        _ = kwargs                                      # Unused arguments
        if self.system == &#39;skiers&#39;:
            li = np.array(li)                           # Segment lengths
            mi = np.array(mi)                           # Skier weights
            ki = np.array(ki)                           # Crack
            k0 = np.array(k0)                           # No crack
        elif self.system == &#39;pst-&#39;:
            li = np.array([L - a, a])                   # Segment lengths
            mi = np.array([0])                          # Skier weights
            ki = np.array([True, False])                # No crack
            k0 = np.array([True, True])                 # Crack
        elif self.system == &#39;-pst&#39;:
            li = np.array([a, L - a])                   # Segment lengths
            mi = np.array([0])                          # Skier weights
            ki = np.array([False, True])                # No crack
            k0 = np.array([True, True])                 # Crack
        elif self.system == &#39;skier&#39;:
            lb = (L - a)/2                              # Half bedded length
            lf = a/2                                    # Half free length
            li = np.array([lb, lf, lf, lb])             # Segment lengths
            mi = np.array([0, m, 0])                    # Skier weights
            ki = np.array([True, False, False, True])   # No crack
            k0 = np.array([True, True, True, True])     # Crack
        else:
            raise ValueError(f&#39;System {self.system} is not implemented.&#39;)

        # Fill dictionary
        segments = {
            &#39;nocrack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: k0},
            &#39;crack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki},
            &#39;both&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki, &#39;k0&#39;: k0}}

        return segments

    def assemble_and_solve(self, phi, li, mi, ki):
        &#34;&#34;&#34;
        Compute free constants for arbitrary beam assembly.

        Assemble LHS from bedded and free segments in the form
        [][zh1  0   0  ...  0   0   0][][][]  left
        [] = [zh1 zh2  0  ...  0   0   0][] + [] = []  mid
        [][0  zh2 zh3 ...  0   0   0][][][]  mid
        [z0][... ... ... ... ... ... ...][C][zp][rhs]  mid
        [][0   0   0  ... zhL zhM  0][][][]  mid
        [][0   0   0  ...  0  zhM zhN][][][]  mid
        [][0   0   0  ...  0   0  zhN][][][]  right
        and solve for constants C.

        Arguments
        ---------
        phi: float
            Inclination(degrees).
        li: ndarray
            List of lengths of segements(mm).
        mi: ndarray
            List of skier weigths(kg) at segement boundaries.
        ki: ndarray
            List of one bool per segement indicating whether segement
            has foundation(True) or not (False).

        Returns
        -------
        C: ndarray
            Matrix(6xN) of solution constants for a system of N
            segements. Columns contain the 6 constants of each segement.
        &#34;&#34;&#34;
        # --- CATCH ERRORS ----------------------------------------------------

        # No foundation
        if not any(ki):
            raise ValueError(&#39;Provide at least one bedded segment.&#39;)
        # Mismatch of number of segements and transisions
        if len(li) != len(ki) or len(li)-1 != len(mi):
            raise ValueError(&#39;Make sure len(li)=N, len(ki)=N, and &#39;
                             &#39;len(mi)=N-1 for a system of N segments.&#39;)

        if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
            # Boundary segements must be on foundation for infinite BCs
            if not all([ki[0], ki[-1]]):
                raise ValueError(&#39;Provide bedded boundary segments in &#39;
                                 &#39;order to account for infinite extensions.&#39;)
            # Make sure infinity boundary conditions are far enough from skiers
            if li[0] &lt; 5e3 or li[-1] &lt; 5e3:
                print((&#39;WARNING: Boundary segments are short. Make sure &#39;
                       &#39;the complementary solution has decayed to the &#39;
                       &#39;boundaries.&#39;))

        # --- PREPROCESSING ---------------------------------------------------

        # Determine size of linear system of equations
        nS = len(li)            # Number of beam segments
        nDOF = 6                # Number of free constants per segment

        # Add dummy segment if only one segment provided
        if nS == 1:
            li.append(0)
            ki.append(True)
            mi.append(0)
            nS = 2

        # Assemble position vector
        pi = np.full(nS, &#39;m&#39;)
        pi[0], pi[-1] = &#39;l&#39;, &#39;r&#39;

        # Initialize matrices
        zh0 = np.zeros([nS*6, nS*nDOF])
        zp0 = np.zeros([nS*6, 1])
        rhs = np.zeros([nS*6, 1])

        # --- ASSEMBLE LINEAR SYSTEM OF EQUATIONS -----------------------------

        # Loop through segments to assemble left-hand side
        for i in range(nS):
            # Length, foundation and position of segment i
            l, k, pos = li[i], ki[i], pi[i]
            # Transmission conditions at left and right segment ends
            zhi = self.eqs(
                zl=self.zh(x=0, l=l, bed=k),
                zr=self.zh(x=l, l=l, bed=k),
                pos=pos)
            zpi = self.eqs(
                zl=self.zp(x=0, phi=phi, bed=k),
                zr=self.zp(x=l, phi=phi, bed=k),
                pos=pos)
            # Rows for left-hand side assembly
            start = 0 if i == 0 else 3
            stop = 6 if i == nS-1 else 9
            # Assemble left-hand side
            zh0[(6*i-start):(6*i+stop), i*nDOF:(i+1)*nDOF] = zhi
            zp0[(6*i-start):(6*i+stop)] += zpi

        # Loop through loads to assemble right-hand side
        for i, m in enumerate(mi, start=1):
            # Get skier loads
            Fn, Ft = self.get_skier_load(m, phi)
            # Right-hand side for transmission from segment i-1 to segment i
            rhs[6*i:6*i+3] = np.vstack([Ft, -Ft*self.h/2, Fn])

        # Set rhs so that complementary integral vanishes at boundaries
        if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
            rhs[:3] = self.bc(self.zp(x=0, phi=phi, bed=ki[0]))
            rhs[-3:] = self.bc(self.zp(x=li[-1], phi=phi, bed=ki[-1]))

        # --- SOLVE -----------------------------------------------------------

        # Solve z0 = zh0*C + zp0 = rhs for constants, i.e. zh0*C = rhs - zp0
        C = np.linalg.solve(zh0, rhs - zp0)

        # Sort (nDOF = 6) constants for each segment into columns of a matrix
        return C.reshape([-1, nDOF]).T</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weac.inverse.Inverse" href="inverse.html#weac.inverse.Inverse">Inverse</a></li>
<li><a title="weac.layered.Layered" href="layered.html#weac.layered.Layered">Layered</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="weac.mixins.SolutionMixin.assemble_and_solve"><code class="name flex">
<span>def <span class="ident">assemble_and_solve</span></span>(<span>self, phi, li, mi, ki)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute free constants for arbitrary beam assembly.</p>
<p>Assemble LHS from bedded and free segments in the form
[][zh1
0
0
&hellip;
0
0
0][][][]
left
[] = [zh1 zh2
0
&hellip;
0
0
0][] + [] = []
mid
[][0
zh2 zh3 &hellip;
0
0
0][][][]
mid
[z0][&hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip;][C][zp][rhs]
mid
[][0
0
0
&hellip; zhL zhM
0][][][]
mid
[][0
0
0
&hellip;
0
zhM zhN][][][]
mid
[][0
0
0
&hellip;
0
0
zhN][][][]
right
and solve for constants C.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination(degrees).</dd>
<dt><strong><code>li</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of lengths of segements(mm).</dd>
<dt><strong><code>mi</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of skier weigths(kg) at segement boundaries.</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of one bool per segement indicating whether segement
has foundation(True) or not (False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix(6xN) of solution constants for a system of N
segements. Columns contain the 6 constants of each segement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assemble_and_solve(self, phi, li, mi, ki):
    &#34;&#34;&#34;
    Compute free constants for arbitrary beam assembly.

    Assemble LHS from bedded and free segments in the form
    [][zh1  0   0  ...  0   0   0][][][]  left
    [] = [zh1 zh2  0  ...  0   0   0][] + [] = []  mid
    [][0  zh2 zh3 ...  0   0   0][][][]  mid
    [z0][... ... ... ... ... ... ...][C][zp][rhs]  mid
    [][0   0   0  ... zhL zhM  0][][][]  mid
    [][0   0   0  ...  0  zhM zhN][][][]  mid
    [][0   0   0  ...  0   0  zhN][][][]  right
    and solve for constants C.

    Arguments
    ---------
    phi: float
        Inclination(degrees).
    li: ndarray
        List of lengths of segements(mm).
    mi: ndarray
        List of skier weigths(kg) at segement boundaries.
    ki: ndarray
        List of one bool per segement indicating whether segement
        has foundation(True) or not (False).

    Returns
    -------
    C: ndarray
        Matrix(6xN) of solution constants for a system of N
        segements. Columns contain the 6 constants of each segement.
    &#34;&#34;&#34;
    # --- CATCH ERRORS ----------------------------------------------------

    # No foundation
    if not any(ki):
        raise ValueError(&#39;Provide at least one bedded segment.&#39;)
    # Mismatch of number of segements and transisions
    if len(li) != len(ki) or len(li)-1 != len(mi):
        raise ValueError(&#39;Make sure len(li)=N, len(ki)=N, and &#39;
                         &#39;len(mi)=N-1 for a system of N segments.&#39;)

    if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
        # Boundary segements must be on foundation for infinite BCs
        if not all([ki[0], ki[-1]]):
            raise ValueError(&#39;Provide bedded boundary segments in &#39;
                             &#39;order to account for infinite extensions.&#39;)
        # Make sure infinity boundary conditions are far enough from skiers
        if li[0] &lt; 5e3 or li[-1] &lt; 5e3:
            print((&#39;WARNING: Boundary segments are short. Make sure &#39;
                   &#39;the complementary solution has decayed to the &#39;
                   &#39;boundaries.&#39;))

    # --- PREPROCESSING ---------------------------------------------------

    # Determine size of linear system of equations
    nS = len(li)            # Number of beam segments
    nDOF = 6                # Number of free constants per segment

    # Add dummy segment if only one segment provided
    if nS == 1:
        li.append(0)
        ki.append(True)
        mi.append(0)
        nS = 2

    # Assemble position vector
    pi = np.full(nS, &#39;m&#39;)
    pi[0], pi[-1] = &#39;l&#39;, &#39;r&#39;

    # Initialize matrices
    zh0 = np.zeros([nS*6, nS*nDOF])
    zp0 = np.zeros([nS*6, 1])
    rhs = np.zeros([nS*6, 1])

    # --- ASSEMBLE LINEAR SYSTEM OF EQUATIONS -----------------------------

    # Loop through segments to assemble left-hand side
    for i in range(nS):
        # Length, foundation and position of segment i
        l, k, pos = li[i], ki[i], pi[i]
        # Transmission conditions at left and right segment ends
        zhi = self.eqs(
            zl=self.zh(x=0, l=l, bed=k),
            zr=self.zh(x=l, l=l, bed=k),
            pos=pos)
        zpi = self.eqs(
            zl=self.zp(x=0, phi=phi, bed=k),
            zr=self.zp(x=l, phi=phi, bed=k),
            pos=pos)
        # Rows for left-hand side assembly
        start = 0 if i == 0 else 3
        stop = 6 if i == nS-1 else 9
        # Assemble left-hand side
        zh0[(6*i-start):(6*i+stop), i*nDOF:(i+1)*nDOF] = zhi
        zp0[(6*i-start):(6*i+stop)] += zpi

    # Loop through loads to assemble right-hand side
    for i, m in enumerate(mi, start=1):
        # Get skier loads
        Fn, Ft = self.get_skier_load(m, phi)
        # Right-hand side for transmission from segment i-1 to segment i
        rhs[6*i:6*i+3] = np.vstack([Ft, -Ft*self.h/2, Fn])

    # Set rhs so that complementary integral vanishes at boundaries
    if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
        rhs[:3] = self.bc(self.zp(x=0, phi=phi, bed=ki[0]))
        rhs[-3:] = self.bc(self.zp(x=li[-1], phi=phi, bed=ki[-1]))

    # --- SOLVE -----------------------------------------------------------

    # Solve z0 = zh0*C + zp0 = rhs for constants, i.e. zh0*C = rhs - zp0
    C = np.linalg.solve(zh0, rhs - zp0)

    # Sort (nDOF = 6) constants for each segment into columns of a matrix
    return C.reshape([-1, nDOF]).T</code></pre>
</details>
</dd>
<dt id="weac.mixins.SolutionMixin.bc"><code class="name flex">
<span>def <span class="ident">bc</span></span>(<span>self, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Provide equations for free(pst) or infinite(skiers) ends.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector(6x1) at a certain position x.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bc</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Boundary condition vector(lenght 3) at position x.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bc(self, z):
    &#34;&#34;&#34;
    Provide equations for free(pst) or infinite(skiers) ends.

    Arguments
    ---------
    z: ndarray
        Solution vector(6x1) at a certain position x.

    Returns
    -------
    bc: ndarray
        Boundary condition vector(lenght 3) at position x.
    &#34;&#34;&#34;
    if self.system in [&#39;pst-&#39;, &#39;-pst&#39;]:
        # Free ends
        bc = np.array([self.N(z), self.M(z), self.V(z)])
    elif self.system in [&#39;skier&#39;, &#39;skiers&#39;]:
        # Infinite ends (vanishing complementary solution)
        bc = np.array([self.u(z, z0=0), self.w(z), self.psi(z)])
    else:
        raise ValueError(
            &#39;Boundary conditions not defined for&#39;
            f&#39;system of type {self.system}.&#39;)

    return bc</code></pre>
</details>
</dd>
<dt id="weac.mixins.SolutionMixin.calc_segments"><code class="name flex">
<span>def <span class="ident">calc_segments</span></span>(<span>self, li=False, mi=False, ki=False, k0=False, L=10000.0, a=0, m=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble lists defining the segments.</p>
<p>This includes length(li), foundation(ki, k0), and skier weight(mi).</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>li</code></strong> :&ensp;<code>squence</code>, optional</dt>
<dd>List of lengths of segements(mm). Used for system 'skiers'.</dd>
<dt><strong><code>mi</code></strong> :&ensp;<code>squence</code>, optional</dt>
<dd>List of skier weigths(kg) at segement boundaries. Used for
system 'skiers'.</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>squence</code>, optional</dt>
<dd>List of one bool per segement indicating whether segement
has foundation(True) or not (False) in the cracked state.
Used for system 'skiers'.</dd>
<dt><strong><code>k0</code></strong> :&ensp;<code>squence</code>, optional</dt>
<dd>List of one bool per segement indicating whether segement
has foundation(True) or not (False) in the uncracked state.
Used for system 'skiers'.</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Total length of model(mm). Used for systems 'pst-', '-pst',
and 'skier'.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Crack length(mm).
Used for systems 'pst-', '-pst', and
'skier'.</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Weight of skier(kg) in the axial center of the model.
Used for system 'skier'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>segments</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with lists of segement lengths(li), skier
weights(mi), and foundation booleans in the cracked(ki)
and ncracked(k0) configurations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_segments(self, li=False, mi=False, ki=False, k0=False,
                  L=1e4, a=0, m=0, **kwargs):
    &#34;&#34;&#34;
    Assemble lists defining the segments.

    This includes length(li), foundation(ki, k0), and skier weight(mi).

    Arguments
    ---------
    li: squence, optional
        List of lengths of segements(mm). Used for system &#39;skiers&#39;.
    mi: squence, optional
        List of skier weigths(kg) at segement boundaries. Used for
        system &#39;skiers&#39;.
    ki: squence, optional
        List of one bool per segement indicating whether segement
        has foundation(True) or not (False) in the cracked state.
        Used for system &#39;skiers&#39;.
    k0: squence, optional
        List of one bool per segement indicating whether segement
        has foundation(True) or not (False) in the uncracked state.
        Used for system &#39;skiers&#39;.
    L: float, optional
        Total length of model(mm). Used for systems &#39;pst-&#39;, &#39;-pst&#39;,
        and &#39;skier&#39;.
    a: float, optional
        Crack length(mm).  Used for systems &#39;pst-&#39;, &#39;-pst&#39;, and
        &#39;skier&#39;.
    m: float, optional
        Weight of skier(kg) in the axial center of the model.
        Used for system &#39;skier&#39;.

    Returns
    -------
    segments: dict
        Dictionary with lists of segement lengths(li), skier
        weights(mi), and foundation booleans in the cracked(ki)
        and ncracked(k0) configurations.
    &#34;&#34;&#34;
    _ = kwargs                                      # Unused arguments
    if self.system == &#39;skiers&#39;:
        li = np.array(li)                           # Segment lengths
        mi = np.array(mi)                           # Skier weights
        ki = np.array(ki)                           # Crack
        k0 = np.array(k0)                           # No crack
    elif self.system == &#39;pst-&#39;:
        li = np.array([L - a, a])                   # Segment lengths
        mi = np.array([0])                          # Skier weights
        ki = np.array([True, False])                # No crack
        k0 = np.array([True, True])                 # Crack
    elif self.system == &#39;-pst&#39;:
        li = np.array([a, L - a])                   # Segment lengths
        mi = np.array([0])                          # Skier weights
        ki = np.array([False, True])                # No crack
        k0 = np.array([True, True])                 # Crack
    elif self.system == &#39;skier&#39;:
        lb = (L - a)/2                              # Half bedded length
        lf = a/2                                    # Half free length
        li = np.array([lb, lf, lf, lb])             # Segment lengths
        mi = np.array([0, m, 0])                    # Skier weights
        ki = np.array([True, False, False, True])   # No crack
        k0 = np.array([True, True, True, True])     # Crack
    else:
        raise ValueError(f&#39;System {self.system} is not implemented.&#39;)

    # Fill dictionary
    segments = {
        &#39;nocrack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: k0},
        &#39;crack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki},
        &#39;both&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki, &#39;k0&#39;: k0}}

    return segments</code></pre>
</details>
</dd>
<dt id="weac.mixins.SolutionMixin.eqs"><code class="name flex">
<span>def <span class="ident">eqs</span></span>(<span>self, zl, zr, pos='mid')</span>
</code></dt>
<dd>
<div class="desc"><p>Provide boundary or transmission conditions for beam segments.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>zl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector(6x1) at left end of beam segement.</dd>
<dt><strong><code>zr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector(6x1) at right end of beam segement.</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>{'left', 'mid', 'right', 'l', 'm', 'r'}</code>, optional</dt>
<dd>Determines whether the segement under consideration
is a left boundary segement(left, l), one of the
center segement(mid, m), or a right boundary
segement(right, r). Default is 'mid'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eqs</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Vector(of length 9) of boundary conditions(3) and
transmission conditions(6) for boundary segements
or vector of transmission conditions(of length 6+6)
for center segments.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eqs(self, zl, zr, pos=&#39;mid&#39;):
    &#34;&#34;&#34;
    Provide boundary or transmission conditions for beam segments.

    Arguments
    ---------
    zl: ndarray
        Solution vector(6x1) at left end of beam segement.
    zr: ndarray
        Solution vector(6x1) at right end of beam segement.
    pos: {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
        Determines whether the segement under consideration
        is a left boundary segement(left, l), one of the
        center segement(mid, m), or a right boundary
        segement(right, r). Default is &#39;mid&#39;.

    Returns
    -------
    eqs: ndarray
        Vector(of length 9) of boundary conditions(3) and
        transmission conditions(6) for boundary segements
        or vector of transmission conditions(of length 6+6)
        for center segments.
    &#34;&#34;&#34;
    if pos in (&#39;l&#39;, &#39;left&#39;):
        eqs = np.array([
            self.bc(zl)[0],             # Left boundary condition
            self.bc(zl)[1],             # Left boundary condition
            self.bc(zl)[2],             # Left boundary condition
            self.u(zr, z0=0),           # ui(xi = li)
            self.w(zr),                 # wi(xi = li)
            self.psi(zr),               # psii(xi = li)
            self.N(zr),                 # Ni(xi = li)
            self.M(zr),                 # Mi(xi = li)
            self.V(zr)])                # Vi(xi = li)
    elif pos in (&#39;m&#39;, &#39;mid&#39;):
        eqs = np.array([
            -self.u(zl, z0=0),          # -ui(xi = 0)
            -self.w(zl),                # -wi(xi = 0)
            -self.psi(zl),              # -psii(xi = 0)
            -self.N(zl),                # -Ni(xi = 0)
            -self.M(zl),                # -Mi(xi = 0)
            -self.V(zl),                # -Vi(xi = 0)
            self.u(zr, z0=0),           # ui(xi = li)
            self.w(zr),                 # wi(xi = li)
            self.psi(zr),               # psii(xi = li)
            self.N(zr),                 # Ni(xi = li)
            self.M(zr),                 # Mi(xi = li)
            self.V(zr)])                # Vi(xi = li)
    elif pos in (&#39;r&#39;, &#39;right&#39;):
        eqs = np.array([
            -self.u(zl, z0=0),          # -ui(xi = 0)
            -self.w(zl),                # -wi(xi = 0)
            -self.psi(zl),              # -psii(xi = 0)
            -self.N(zl),                # -Ni(xi = 0)
            -self.M(zl),                # -Mi(xi = 0)
            -self.V(zl),                # -Vi(xi = 0)
            self.bc(zr)[0],             # Right boundary condition
            self.bc(zr)[1],             # Right boundary condition
            self.bc(zr)[2]])            # Right boundary condition
    else:
        raise ValueError(
            (f&#39;Invalid position argument {pos} given. &#39;
             &#39;Valid segment positions are l, m, and r, &#39;
             &#39;or left, mid and right.&#39;))

    return eqs</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weac" href="index.html">weac</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weac.mixins.AnalysisMixin" href="#weac.mixins.AnalysisMixin">AnalysisMixin</a></code></h4>
<ul class="">
<li><code><a title="weac.mixins.AnalysisMixin.gdif" href="#weac.mixins.AnalysisMixin.gdif">gdif</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.ginc" href="#weac.mixins.AnalysisMixin.ginc">ginc</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.rasterize_solution" href="#weac.mixins.AnalysisMixin.rasterize_solution">rasterize_solution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weac.mixins.FieldQuantitiesMixin" href="#weac.mixins.FieldQuantitiesMixin">FieldQuantitiesMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="weac.mixins.FieldQuantitiesMixin.Gi" href="#weac.mixins.FieldQuantitiesMixin.Gi">Gi</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.Gii" href="#weac.mixins.FieldQuantitiesMixin.Gii">Gii</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.M" href="#weac.mixins.FieldQuantitiesMixin.M">M</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.N" href="#weac.mixins.FieldQuantitiesMixin.N">N</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.V" href="#weac.mixins.FieldQuantitiesMixin.V">V</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.eps" href="#weac.mixins.FieldQuantitiesMixin.eps">eps</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.gamma" href="#weac.mixins.FieldQuantitiesMixin.gamma">gamma</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.int1" href="#weac.mixins.FieldQuantitiesMixin.int1">int1</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.int2" href="#weac.mixins.FieldQuantitiesMixin.int2">int2</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.maxp" href="#weac.mixins.FieldQuantitiesMixin.maxp">maxp</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.psi" href="#weac.mixins.FieldQuantitiesMixin.psi">psi</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.psip" href="#weac.mixins.FieldQuantitiesMixin.psip">psip</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.sig" href="#weac.mixins.FieldQuantitiesMixin.sig">sig</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.tau" href="#weac.mixins.FieldQuantitiesMixin.tau">tau</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.u" href="#weac.mixins.FieldQuantitiesMixin.u">u</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.up" href="#weac.mixins.FieldQuantitiesMixin.up">up</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.w" href="#weac.mixins.FieldQuantitiesMixin.w">w</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.wp" href="#weac.mixins.FieldQuantitiesMixin.wp">wp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weac.mixins.SolutionMixin" href="#weac.mixins.SolutionMixin">SolutionMixin</a></code></h4>
<ul class="">
<li><code><a title="weac.mixins.SolutionMixin.assemble_and_solve" href="#weac.mixins.SolutionMixin.assemble_and_solve">assemble_and_solve</a></code></li>
<li><code><a title="weac.mixins.SolutionMixin.bc" href="#weac.mixins.SolutionMixin.bc">bc</a></code></li>
<li><code><a title="weac.mixins.SolutionMixin.calc_segments" href="#weac.mixins.SolutionMixin.calc_segments">calc_segments</a></code></li>
<li><code><a title="weac.mixins.SolutionMixin.eqs" href="#weac.mixins.SolutionMixin.eqs">eqs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>