<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>weac.mixins API documentation</title>
<meta name="description" content="Mixins for the elastic analysis of layered snow slabs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>weac.mixins</code></h1>
</header>
<section id="section-intro">
<p>Mixins for the elastic analysis of layered snow slabs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Mixins for the elastic analysis of layered snow slabs.&#34;&#34;&#34;
# pylint: disable=invalid-name,too-many-locals,too-many-arguments

# Standard library imports
from functools import partial


# Third party imports
import numpy as np
from scipy.integrate import romberg, cumulative_trapezoid

# Module imports
from weac.tools import tensile_strength_slab


class FieldQuantitiesMixin:
    &#34;&#34;&#34;
    Mixin for field quantities.

    Provides methods for the computation of displacements, stresses,
    strains, and energy release rates from the solution vector.
    &#34;&#34;&#34;

    # pylint: disable=no-self-use
    def w(self, Z, unit=&#39;mm&#39;):
        &#34;&#34;&#34;
        Get centerline deflection w.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
            Desired output unit. Default is mm.

        Returns
        -------
        float
            Deflection w (in specified unit) of the slab.
        &#34;&#34;&#34;
        convert = {
            &#39;m&#39;: 1e-3,   # meters
            &#39;cm&#39;: 1e-1,  # centimeters
            &#39;mm&#39;: 1,     # millimeters
            &#39;um&#39;: 1e3    # micrometers
        }
        return convert[unit]*Z[2, :]

    def dw_dx(self, Z):
        &#34;&#34;&#34;
        Get first derivative w&#39; of the centerline deflection.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            First derivative w&#39; of the deflection of the slab.
        &#34;&#34;&#34;
        return Z[3, :]

    def psi(self, Z, unit=&#39;rad&#39;):
        &#34;&#34;&#34;
        Get midplane rotation psi.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        unit : {&#39;deg&#39;, &#39;degrees&#39;, &#39;rad&#39;, &#39;radians&#39;}, optional
            Desired output unit. Default is radians.

        Returns
        -------
        psi : float
            Cross-section rotation psi (radians) of the slab.
        &#34;&#34;&#34;
        if unit in [&#39;deg&#39;, &#39;degree&#39;, &#39;degrees&#39;]:
            psi = np.rad2deg(Z[4, :])
        elif unit in [&#39;rad&#39;, &#39;radian&#39;, &#39;radians&#39;]:
            psi = Z[4, :]
        return psi

    def dpsi_dx(self, Z):
        &#34;&#34;&#34;
        Get first derivative psi&#39; of the midplane rotation.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            First derivative psi&#39; of the midplane rotation (radians/mm)
            of the slab.
        &#34;&#34;&#34;
        return Z[5, :]

    # pylint: enable=no-self-use
    def u(self, Z, z0, unit=&#39;mm&#39;):
        &#34;&#34;&#34;
        Get horizontal displacement u = u0 + z0 psi.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        z0 : float
            Z-coordinate (mm) where u is to be evaluated.
        unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
            Desired output unit. Default is mm.

        Returns
        -------
        float
            Horizontal displacement u (unit) of the slab.
        &#34;&#34;&#34;
        convert = {
            &#39;m&#39;: 1e-3,   # meters
            &#39;cm&#39;: 1e-1,  # centimeters
            &#39;mm&#39;: 1,     # millimeters
            &#39;um&#39;: 1e3    # micrometers
        }
        return convert[unit]*(Z[0, :] + z0*self.psi(Z))

    def du_dx(self, Z, z0):
        &#34;&#34;&#34;
        Get first derivative of the horizontal displacement.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        z0 : float
            Z-coordinate (mm) where u is to be evaluated.

        Returns
        -------
        float
            First derivative u&#39; = u0&#39; + z0 psi&#39; of the horizontal
            displacement of the slab.
        &#34;&#34;&#34;
        return Z[1, :] + z0*self.dpsi_dx(Z)

    def N(self, Z):
        &#34;&#34;&#34;
        Get the axial normal force N = A11 u&#39; + B11 psi&#39; in the slab.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Axial normal force N (N) in the slab.
        &#34;&#34;&#34;
        return self.A11*Z[1, :] + self.B11*Z[5, :]

    def M(self, Z):
        &#34;&#34;&#34;
        Get bending moment M = B11 u&#39; + D11 psi&#39; in the slab.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Bending moment M (Nmm) in the slab.
        &#34;&#34;&#34;
        return self.B11*Z[1, :] + self.D11*Z[5, :]

    def V(self, Z):
        &#34;&#34;&#34;
        Get vertical shear force V = kA55(w&#39; + psi).

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Vertical shear force V (N) in the slab.
        &#34;&#34;&#34;
        return self.kA55*(Z[3, :] + Z[4, :])

    def sig(self, Z, unit=&#39;MPa&#39;):
        &#34;&#34;&#34;
        Get weak-layer normal stress.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
            Desired output unit. Default is MPa.

        Returns
        -------
        float
            Weak-layer normal stress sigma (in specified unit).
        &#34;&#34;&#34;
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }
        return -convert[unit]*self.kn*self.w(Z)

    def tau(self, Z, unit=&#39;MPa&#39;):
        &#34;&#34;&#34;
        Get weak-layer shear stress.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
            Desired output unit. Default is MPa.

        Returns
        -------
        float
            Weak-layer shear stress tau (in specified unit).
        &#34;&#34;&#34;
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }
        return -convert[unit]*self.kt*(
            self.dw_dx(Z)*self.t/2 - self.u(Z, z0=self.h/2))

    def eps(self, Z):
        &#34;&#34;&#34;
        Get weak-layer normal strain.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Weak-layer normal strain epsilon.
        &#34;&#34;&#34;
        return -self.w(Z)/self.t

    def gamma(self, Z):
        &#34;&#34;&#34;
        Get weak-layer shear strain.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Weak-layer shear strain gamma.
        &#34;&#34;&#34;
        return self.dw_dx(Z)/2 - self.u(Z, z0=self.h/2)/self.t

    def Gi(self, Ztip, unit=&#39;kJ/m^2&#39;):
        &#34;&#34;&#34;
        Get mode I differential energy release rate at crack tip.

        Arguments
        ---------
        Ztip : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
            at the crack tip.
        unit : {&#39;N/mm&#39;, &#39;kJ/m^2&#39;, &#39;J/m^2&#39;}, optional
            Desired output unit. Default is kJ/m^2.

        Returns
        -------
        float
            Mode I differential energy release rate (N/mm = kJ/m^2
            or J/m^2) at the crack tip.
        &#34;&#34;&#34;
        convert = {
            &#39;J/m^2&#39;: 1e3,   # joule per square meter
            &#39;kJ/m^2&#39;: 1,    # kilojoule per square meter
            &#39;N/mm&#39;: 1       # newton per millimeter
        }
        return convert[unit]*self.sig(Ztip)**2/(2*self.kn)

    def Gii(self, Ztip, unit=&#39;kJ/m^2&#39;):
        &#34;&#34;&#34;
        Get mode II differential energy release rate at crack tip.

        Arguments
        ---------
        Ztip : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
            at the crack tip.
        unit : {&#39;N/mm&#39;, &#39;kJ/m^2&#39;, &#39;J/m^2&#39;}, optional
            Desired output unit. Default is kJ/m^2 = N/mm.

        Returns
        -------
        float
            Mode II differential energy release rate (N/mm = kJ/m^2
            or J/m^2) at the crack tip.
        &#34;&#34;&#34;
        convert = {
            &#39;J/m^2&#39;: 1e3,   # joule per square meter
            &#39;kJ/m^2&#39;: 1,    # kilojoule per square meter
            &#39;N/mm&#39;: 1       # newton per millimeter
        }
        return convert[unit]*self.tau(Ztip)**2/(2*self.kt)

    def int1(self, x, z0, z1):
        &#34;&#34;&#34;
        Get mode I crack opening integrand at integration points xi.

        Arguments
        ---------
        x : float, ndarray
            X-coordinate where integrand is to be evaluated (mm).
        z0 : callable
            Function that returns the solution vector of the uncracked
            configuration.
        z1 : callable
            Function that returns the solution vector of the cracked
            configuration.

        Returns
        -------
        float or ndarray
            Integrant of the mode I crack opening integral.
        &#34;&#34;&#34;
        return self.sig(z0(x))*self.eps(z1(x))*self.t

    def int2(self, x, z0, z1):
        &#34;&#34;&#34;
        Get mode II crack opening integrand at integration points xi.

        Arguments
        ---------
        x : float, ndarray
            X-coordinate where integrand is to be evaluated (mm).
        z0 : callable
            Function that returns the solution vector of the uncracked
            configuration.
        z1 : callable
            Function that returns the solution vector of the cracked
            configuration.

        Returns
        -------
        float or ndarray
            Integrant of the mode II crack opening integral.
        &#34;&#34;&#34;
        return self.tau(z0(x))*self.gamma(z1(x))*self.t

    def dz_dx(self, z, phi):
        &#34;&#34;&#34;
        Get first derivative z&#39;(x) = K*z(x) + q of the solution vector.

        z&#39;(x) = [u&#39;(x) u&#39;&#39;(x) w&#39;(x) w&#39;&#39;(x) psi&#39;(x), psi&#39;&#39;(x)]^T

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            First derivative z&#39;(x) for the solution vector (6x1).
        &#34;&#34;&#34;
        K = self.calc_system_matrix()
        q = self.get_load_vector(phi)
        return np.dot(K, z) + q

    def dz_dxdx(self, z, phi):
        &#34;&#34;&#34;
        Get second derivative z&#39;&#39;(x) = K*z&#39;(x) of the solution vector.

        z&#39;&#39;(x) = [u&#39;&#39;(x) u&#39;&#39;&#39;(x) w&#39;&#39;(x) w&#39;&#39;&#39;(x) psi&#39;&#39;(x), psi&#39;&#39;&#39;(x)]^T

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Second derivative z&#39;&#39;(x) = (K*z(x) + q)&#39; = K*z&#39;(x) = K*(K*z(x) + q)
            of the solution vector (6x1).
        &#34;&#34;&#34;
        K = self.calc_system_matrix()
        q = self.get_load_vector(phi)
        dz_dx = np.dot(K, z) + q
        return np.dot(K, dz_dx)

    def du0_dxdx(self, z, phi):
        &#34;&#34;&#34;
        Get second derivative of the horiz. centerline displacement u0&#39;&#39;(x).

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Second derivative of the horizontal centerline displacement
            u0&#39;&#39;(x) (1/mm).
        &#34;&#34;&#34;
        return self.dz_dx(z, phi)[1, :]

    def dpsi_dxdx(self, z, phi):
        &#34;&#34;&#34;
        Get second derivative of the cross-section rotation psi&#39;&#39;(x).

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Second derivative of the cross-section rotation psi&#39;&#39;(x) (1/mm^2).
        &#34;&#34;&#34;
        return self.dz_dx(z, phi)[5, :]

    def du0_dxdxdx(self, z, phi):
        &#34;&#34;&#34;
        Get third derivative of the horiz. centerline displacement u0&#39;&#39;&#39;(x).

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Third derivative of the horizontal centerline displacement
            u0&#39;&#39;&#39;(x) (1/mm^2).
        &#34;&#34;&#34;
        return self.dz_dxdx(z, phi)[1, :]

    def dpsi_dxdxdx(self, z, phi):
        &#34;&#34;&#34;
        Get third derivative of the cross-section rotation psi&#39;&#39;&#39;(x).

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Third derivative of the cross-section rotation psi&#39;&#39;&#39;(x) (1/mm^3).
        &#34;&#34;&#34;
        return self.dz_dxdx(z, phi)[5, :]

class SolutionMixin:
    &#34;&#34;&#34;
    Mixin for the solution of boundary value problems.

    Provides methods for the assembly of the system of equations
    and for the computation of the free constants.
    &#34;&#34;&#34;

    def mode_td(self, l=0):
        &#34;&#34;&#34;
        Identify the mode of the pst-boundary.

        Arguments
        ---------
        l : float, optional
            Length of the segment in consideration. Default is zero.

        Returns
        -------
        mode : string
            Contains the mode for the boundary of the segment:
            A - free end, B - intermediate touchdown,
            C - full touchdown (maximum clamped end).
        &#34;&#34;&#34;
        # Classify boundary type by element length
        if l &lt;= self.lC:
            mode = &#39;A&#39;
        elif self.lC &lt; l &lt;= self.lS:
            mode = &#39;B&#39;
        elif self.lS &lt; l:
            mode = &#39;C&#39;

        return mode

    def reduce_stiffness(self, l=0, mode=&#39;A&#39;):
        &#34;&#34;&#34;
        Determines the reduction factor for a rotational spring.

        Arguments
        ---------
        l : float, optional
            Length of the segment in consideration. Default is zero.
        mode : string, optional
            Contains the mode for the boundary of the segment:
            A - free end, B - intermediate touchdown, C - full touchdown.
            Default is A.

        Returns
        -------
        kf : float
            Reduction factor.
        &#34;&#34;&#34;
        # Reduction to zero for free end bc
        if mode in [&#39;A&#39;]:
            kf = 0
        # Reduction factor for touchdown
        if mode in [&#39;B&#39;, &#39;C&#39;]:
            l = l - self.lC
            # Beta needs to take into account different weak-layer spring stiffness
            beta = self.beta*self.ratio**(1/4)
            kf=(np.cos(2*beta*l)+np.cosh(2*beta*l)-2)/(np.sin(2*beta*l)+np.sinh(2*beta*l))

        return kf

    def bc(self, z, l=0, k=False, pos=&#39;mid&#39;):
        &#34;&#34;&#34;
        Provide equations for free (pst) or infinite (skiers) ends.

        Arguments
        ---------
        z : ndarray
            Solution vector (6x1) at a certain position x.
        l : float, optional
            Length of the segment in consideration. Default is zero.
        k : boolean
            Indicates whether segment has foundation(True) or not (False).
            Default is False.
        pos : {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
            Determines whether the segement under consideration
            is a left boundary segement (left, l), one of the
            center segement (mid, m), or a right boundary
            segement (right, r). Default is &#39;mid&#39;.

        Returns
        -------
        bc : ndarray
            Boundary condition vector (lenght 3) at position x.
        &#34;&#34;&#34;
        # Check mode for free end
        mode = self.mode_td(l=l)
        # Get spring stiffness reduction factor
        kf = self.reduce_stiffness(l=l, mode=mode)
        # Get spring stiffness for collapsed weak-layer
        kR = self.calc_rot_spring(collapse=True)

        # Set boundary conditions for PST-systems
        if self.system in [&#39;pst-&#39;, &#39;-pst&#39;]:
            if not k:
                if mode in [&#39;A&#39;]:
                    # Free end
                    bc = np.array([self.N(z),
                                   self.M(z),
                                   self.V(z)
                                   ])
                elif mode in [&#39;B&#39;, &#39;C&#39;] and pos in [&#39;r&#39;, &#39;right&#39;]:
                    # Touchdown right
                    bc = np.array([self.N(z),
                                   self.M(z) + kf*kR*self.psi(z),
                                   self.w(z)
                                   ])
                elif mode in [&#39;B&#39;, &#39;C&#39;] and pos in [&#39;l&#39;, &#39;left&#39;]:
                    # Touchdown left
                    bc = np.array([self.N(z),
                                   self.M(z) - kf*kR*self.psi(z),
                                   self.w(z)
                                   ])
            else:
                # Free end
                bc = np.array([self.N(z),
                                self.M(z),
                                self.V(z)
                                ])
        # Set boundary conditions for SKIER-systems
        elif self.system in [&#39;skier&#39;, &#39;skiers&#39;]:
            # Infinite end (vanishing complementary solution)
            bc = np.array([self.u(z, z0=0),
                           self.w(z),
                           self.psi(z)
                           ])
        else:
            raise ValueError(
                &#39;Boundary conditions not defined for&#39;
                f&#39;system of type {self.system}.&#39;)

        return bc

    def eqs(self, zl, zr, l=0, k=False, pos=&#39;mid&#39;):
        &#34;&#34;&#34;
        Provide boundary or transmission conditions for beam segments.

        Arguments
        ---------
        zl : ndarray
            Solution vector (6x1) at left end of beam segement.
        zr : ndarray
            Solution vector (6x1) at right end of beam segement.
        l : float, optional
            Length of the segment in consideration. Default is zero.
        k : boolean
            Indicates whether segment has foundation(True) or not (False).
            Default is False.
        pos: {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
            Determines whether the segement under consideration
            is a left boundary segement (left, l), one of the
            center segement (mid, m), or a right boundary
            segement (right, r). Default is &#39;mid&#39;.

        Returns
        -------
        eqs : ndarray
            Vector (of length 9) of boundary conditions (3) and
            transmission conditions (6) for boundary segements
            or vector of transmission conditions (of length 6+6)
            for center segments.
        &#34;&#34;&#34;
        if pos in (&#39;l&#39;, &#39;left&#39;):
            eqs = np.array([
                self.bc(zl, l, k, pos)[0],             # Left boundary condition
                self.bc(zl, l, k, pos)[1],             # Left boundary condition
                self.bc(zl, l, k, pos)[2],             # Left boundary condition
                self.u(zr, z0=0),           # ui(xi = li)
                self.w(zr),                 # wi(xi = li)
                self.psi(zr),               # psii(xi = li)
                self.N(zr),                 # Ni(xi = li)
                self.M(zr),                 # Mi(xi = li)
                self.V(zr)])                # Vi(xi = li)
        elif pos in (&#39;m&#39;, &#39;mid&#39;):
            eqs = np.array([
                -self.u(zl, z0=0),          # -ui(xi = 0)
                -self.w(zl),                # -wi(xi = 0)
                -self.psi(zl),              # -psii(xi = 0)
                -self.N(zl),                # -Ni(xi = 0)
                -self.M(zl),                # -Mi(xi = 0)
                -self.V(zl),                # -Vi(xi = 0)
                self.u(zr, z0=0),           # ui(xi = li)
                self.w(zr),                 # wi(xi = li)
                self.psi(zr),               # psii(xi = li)
                self.N(zr),                 # Ni(xi = li)
                self.M(zr),                 # Mi(xi = li)
                self.V(zr)])                # Vi(xi = li)
        elif pos in (&#39;r&#39;, &#39;right&#39;):
            eqs = np.array([
                -self.u(zl, z0=0),          # -ui(xi = 0)
                -self.w(zl),                # -wi(xi = 0)
                -self.psi(zl),              # -psii(xi = 0)
                -self.N(zl),                # -Ni(xi = 0)
                -self.M(zl),                # -Mi(xi = 0)
                -self.V(zl),                # -Vi(xi = 0)
                self.bc(zr, l, k, pos)[0],             # Right boundary condition
                self.bc(zr, l, k, pos)[1],             # Right boundary condition
                self.bc(zr, l, k, pos)[2]])            # Right boundary condition
        else:
            raise ValueError(
                (f&#39;Invalid position argument {pos} given. &#39;
                 &#39;Valid segment positions are l, m, and r, &#39;
                 &#39;or left, mid and right.&#39;))
        return eqs

    def calc_segments(self, tdi=False, li=False, mi=False, ki=False, k0=False,
                      L=1e4, a=0, m=0, **kwargs):
        &#34;&#34;&#34;
        Assemble lists defining the segments.

        This includes length (li), foundation (ki, k0), and skier
        weight (mi).

        Arguments
        ---------
        li : squence, optional
            List of lengths of segements(mm). Used for system &#39;skiers&#39;.
        mi : squence, optional
            List of skier weigths (kg) at segement boundaries. Used for
            system &#39;skiers&#39;.
        ki : squence, optional
            List of one bool per segement indicating whether segement
            has foundation (True) or not (False) in the cracked state.
            Used for system &#39;skiers&#39;.
        k0 : squence, optional
            List of one bool per segement indicating whether segement
            has foundation(True) or not (False) in the uncracked state.
            Used for system &#39;skiers&#39;.
        L : float, optional
            Total length of model (mm). Used for systems &#39;pst-&#39;, &#39;-pst&#39;,
            and &#39;skier&#39;.
        a : float, optional
            Crack length (mm).  Used for systems &#39;pst-&#39;, &#39;-pst&#39;, and
            &#39;skier&#39;.
        phi : float, optional
            Inclination (degree).
        m : float, optional
            Weight of skier (kg) in the axial center of the model.
            Used for system &#39;skier&#39;.

        Returns
        -------
        segments : dict
            Dictionary with lists of touchdown booleans (tdi), segement
            lengths (li), skier weights (mi), and foundation booleans
            in the cracked (ki) and uncracked (k0) configurations.
        &#34;&#34;&#34;

        _ = kwargs                                      # Unused arguments
        # Set unbedded segment length
        mode = self.mode_td(l=a)
        if mode in [&#39;A&#39;, &#39;B&#39;]:
            lU = a
        if mode in [&#39;C&#39;]:
            lU = self.lS

        # Assemble list defining the segments
        if self.system == &#39;skiers&#39;:
            li = np.array(li)                           # Segment lengths
            mi = np.array(mi)                           # Skier weights
            ki = np.array(ki)                           # Crack
            k0 = np.array(k0)                           # No crack
        elif self.system == &#39;pst-&#39;:
            li = np.array([L - a, lU])                   # Segment lengths
            mi = np.array([0])                          # Skier weights
            ki = np.array([True, False])                # Crack
            k0 = np.array([True, True])                 # No crack
        elif self.system == &#39;-pst&#39;:
            li = np.array([lU, L - a])                   # Segment lengths
            mi = np.array([0])                          # Skier weights
            ki = np.array([False, True])                # Crack
            k0 = np.array([True, True])                 # No crack
        elif self.system == &#39;skier&#39;:
            lb = (L - a)/2                              # Half supported length
            lf = a/2                                    # Half free length
            li = np.array([lb, lf, lf, lb])             # Segment lengths
            mi = np.array([0, m, 0])                    # Skier weights
            ki = np.array([True, False, False, True])   # Crack
            k0 = np.array([True, True, True, True])     # No crack
        else:
            raise ValueError(f&#39;System {self.system} is not implemented.&#39;)

        # Fill dictionary
        segments = {
            &#39;nocrack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: k0},
            &#39;crack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki},
            &#39;both&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki, &#39;k0&#39;: k0}}
        return segments

    def assemble_and_solve(self, phi, li, mi, ki):
        &#34;&#34;&#34;
        Compute free constants for arbitrary beam assembly.

        Assemble LHS from supported and unsupported segments in the form
        [  ]   [ zh1  0   0  ...  0   0   0  ][   ]   [    ]   [     ]  left
        [  ]   [ zh1 zh2  0  ...  0   0   0  ][   ]   [    ]   [     ]  mid
        [  ]   [  0  zh2 zh3 ...  0   0   0  ][   ]   [    ]   [     ]  mid
        [z0] = [ ... ... ... ... ... ... ... ][ C ] + [ zp ] = [ rhs ]  mid
        [  ]   [  0   0   0  ... zhL zhM  0  ][   ]   [    ]   [     ]  mid
        [  ]   [  0   0   0  ...  0  zhM zhN ][   ]   [    ]   [     ]  mid
        [  ]   [  0   0   0  ...  0   0  zhN ][   ]   [    ]   [     ]  right
        and solve for constants C.

        Arguments
        ---------
        phi : float
            Inclination (degrees).
        li : ndarray
            List of lengths of segements (mm).
        mi : ndarray
            List of skier weigths (kg) at segement boundaries.
        ki : ndarray
            List of one bool per segement indicating whether segement
            has foundation (True) or not (False).

        Returns
        -------
        C : ndarray
            Matrix(6xN) of solution constants for a system of N
            segements. Columns contain the 6 constants of each segement.
        &#34;&#34;&#34;
        # --- CATCH ERRORS ----------------------------------------------------

        # No foundation
        if not any(ki):
            raise ValueError(&#39;Provide at least one supported segment.&#39;)
        # Mismatch of number of segements and transisions
        if len(li) != len(ki) or len(li) - 1 != len(mi):
            raise ValueError(&#39;Make sure len(li)=N, len(ki)=N, and &#39;
                             &#39;len(mi)=N-1 for a system of N segments.&#39;)

        if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
            # Boundary segments must be on foundation for infinite BCs
            if not all([ki[0], ki[-1]]):
                raise ValueError(&#39;Provide supported boundary segments in &#39;
                                 &#39;order to account for infinite extensions.&#39;)
            # Make sure infinity boundary conditions are far enough from skiers
            if li[0] &lt; 5e3 or li[-1] &lt; 5e3:
                print((&#39;WARNING: Boundary segments are short. Make sure &#39;
                       &#39;the complementary solution has decayed to the &#39;
                       &#39;boundaries.&#39;))

        # --- PREPROCESSING ---------------------------------------------------

        # Determine size of linear system of equations
        nS = len(li)            # Number of beam segments
        nDOF = 6                # Number of free constants per segment

        # Add dummy segment if only one segment provided
        if nS == 1:
            li.append(0)
            ki.append(True)
            mi.append(0)
            nS = 2

        # Assemble position vector
        pi = np.full(nS, &#39;m&#39;)
        pi[0], pi[-1] = &#39;l&#39;, &#39;r&#39;

        # Initialize matrices
        zh0 = np.zeros([nS*6, nS*nDOF])
        zp0 = np.zeros([nS*6, 1])
        rhs = np.zeros([nS*6, 1])

        # --- ASSEMBLE LINEAR SYSTEM OF EQUATIONS -----------------------------

        # Loop through segments to assemble left-hand side
        for i in range(nS):
            # Length, foundation and position of segment i
            l, k, pos = li[i], ki[i], pi[i]
            # Transmission conditions at left and right segment ends
            zhi = self.eqs(
                zl=self.zh(x=0, l=l, bed=k),
                zr=self.zh(x=l, l=l, bed=k),
                l=l, k=k, pos=pos)
            zpi = self.eqs(
                zl=self.zp(x=0, phi=phi, bed=k),
                zr=self.zp(x=l, phi=phi, bed=k),
                l=l, k=k, pos=pos)
            # Rows for left-hand side assembly
            start = 0 if i == 0 else 3
            stop = 6 if i == nS - 1 else 9
            # Assemble left-hand side
            zh0[(6*i - start):(6*i + stop), i*nDOF:(i + 1)*nDOF] = zhi
            zp0[(6*i - start):(6*i + stop)] += zpi

        # Loop through loads to assemble right-hand side
        for i, m in enumerate(mi, start=1):
            # Get skier loads
            Fn, Ft = self.get_skier_load(m, phi)
            # Right-hand side for transmission from segment i-1 to segment i
            rhs[6*i:6*i + 3] = np.vstack([Ft, -Ft*self.h/2, Fn])
        # Set rhs so that complementary integral vanishes at boundaries
        if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
            rhs[:3] = self.bc(self.zp(x=0, phi=phi, bed=ki[0]))
            rhs[-3:] = self.bc(self.zp(x=li[-1], phi=phi, bed=ki[-1]))

        # Loop through segments to set touchdown at rhs
        for i in range(nS):
            # Length, foundation and position of segment i
            l, k, pos = li[i], ki[i], pi[i]
            mode = self.mode_td(l=l)
            if not k and bool(mode in [&#39;B&#39;, &#39;C&#39;]):
                if i==0:
                    rhs[:3] = np.vstack([0,0,self.tc])
                if i == (nS - 1):
                    rhs[-3:] = np.vstack([0,0,self.tc])

        # --- SOLVE -----------------------------------------------------------

        # Solve z0 = zh0*C + zp0 = rhs for constants, i.e. zh0*C = rhs - zp0
        C = np.linalg.solve(zh0, rhs - zp0)
        # Sort (nDOF = 6) constants for each segment into columns of a matrix
        return C.reshape([-1, nDOF]).T


class AnalysisMixin:
    &#34;&#34;&#34;
    Mixin for the analysis of model outputs.

    Provides methods for the analysis of layered slabs on compliant
    elastic foundations.
    &#34;&#34;&#34;

    def rasterize_solution(self, C, phi, li, ki, num=250, **kwargs):
        &#34;&#34;&#34;
        Compute rasterized solution vector.

        Arguments
        ---------
        C : ndarray
            Vector of free constants.
        phi : float
            Inclination (degrees).
        li : ndarray
            List of segment lengths (mm).
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not.
        num : int
            Number of grid points.

        Returns
        -------
        xq : ndarray
            Grid point x-coordinates at which solution vector
            is discretized.
        zq : ndarray
            Matrix with solution vectors as colums at grid
            points xq.
        xb : ndarray
            Grid point x-coordinates that lie on a foundation.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Drop zero-length segments
        isnonzero = li &gt; 0
        C, ki, li = C[:, isnonzero], ki[isnonzero], li[isnonzero]

        # Compute number of plot points per segment (+1 for last segment)
        nq = np.ceil(li/li.sum()*num).astype(&#39;int&#39;)
        nq[-1] += 1

        # Provide cumulated length and plot point lists
        lic = np.insert(np.cumsum(li), 0, 0)
        nqc = np.insert(np.cumsum(nq), 0, 0)

        # Initialize arrays
        issupported = np.full(nq.sum(), True)
        xq = np.full(nq.sum(), np.nan)
        zq = np.full([6, xq.size], np.nan)

        # Loop through segments
        for i, l in enumerate(li):
            # Get local x-coordinates of segment i
            xi = np.linspace(0, l, num=nq[i], endpoint=(i == li.size - 1))
            # Compute start and end coordinates of segment i
            x0 = lic[i]
            # Assemble global coordinate vector
            xq[nqc[i]:nqc[i + 1]] = x0 + xi
            # Mask coordinates not on foundation (including endpoints)
            if not ki[i]:
                issupported[nqc[i]:nqc[i + 1]] = False
            # Compute segment solution
            zi = self.z(xi, C[:, [i]], l, phi, ki[i])
            # Assemble global solution matrix
            zq[:, nqc[i]:nqc[i + 1]] = zi

        # Make sure cracktips are included
        transmissionbool = [ki[j] or ki[j + 1] for j, _ in enumerate(ki[:-1])]
        for i, truefalse in enumerate(transmissionbool, start=1):
            issupported[nqc[i]] = truefalse

        # Assemble vector of coordinates on foundation
        xb = np.full(nq.sum(), np.nan)
        xb[issupported] = xq[issupported]

        return xq, zq, xb

    def ginc(self, C0, C1, phi, li, ki, k0, **kwargs):
        &#34;&#34;&#34;
        Compute incremental energy relase rate of of all cracks.

        Arguments
        ---------
        C0 : ndarray
            Free constants of uncracked solution.
        C1 : ndarray
            Free constants of cracked solution.
        phi : float
            Inclination (degress).
        li : ndarray
            List of segment lengths.
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the cracked configuration.
        k0 : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the uncracked configuration.

        Returns
        -------
        ndarray
            List of total, mode I, and mode II energy release rates.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Make sure inputs are np.arrays
        li, ki, k0 = np.array(li), np.array(ki), np.array(k0)

        # Reduce inputs to segments with crack advance
        iscrack = k0 &amp; ~ki
        C0, C1, li = C0[:, iscrack], C1[:, iscrack], li[iscrack]

        # Compute total crack lenght and initialize outputs
        da = li.sum() if li.sum() &gt; 0 else np.nan
        Ginc1, Ginc2 = 0, 0

        # Loop through segments with crack advance
        for j, l in enumerate(li):

            # Uncracked (0) and cracked (1) solutions at integration points
            z0 = partial(self.z, C=C0[:, [j]], l=l, phi=phi, bed=True)
            z1 = partial(self.z, C=C1[:, [j]], l=l, phi=phi, bed=False)

            # Mode I (1) and II (2) integrands at integration points
            int1 = partial(self.int1, z0=z0, z1=z1)
            int2 = partial(self.int2, z0=z0, z1=z1)

            # Segement contributions to total crack opening integral
            Ginc1 += romberg(int1, 0, l, rtol=self.tol,
                             vec_func=True)/(2*da)
            Ginc2 += romberg(int2, 0, l, rtol=self.tol,
                             vec_func=True)/(2*da)

        return np.array([Ginc1 + Ginc2, Ginc1, Ginc2]).flatten()

    def gdif(self, C, phi, li, ki, unit=&#39;kJ/m^2&#39;, **kwargs):
        &#34;&#34;&#34;
        Compute differential energy release rate of all crack tips.

        Arguments
        ---------
        C : ndarray
            Free constants of the solution.
        phi : float
            Inclination (degress).
        li : ndarray
            List of segment lengths.
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the cracked configuration.

        Returns
        -------
        ndarray
            List of total, mode I, and mode II energy release rates.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Get number and indices of segment transitions
        ntr = len(li) - 1
        itr = np.arange(ntr)

        # Identify supported-free and free-supported transitions as crack tips
        iscracktip = [ki[j] != ki[j + 1] for j in range(ntr)]

        # Transition indices of crack tips and total number of crack tips
        ict = itr[iscracktip]
        nct = len(ict)

        # Initialize energy release rate array
        Gdif = np.zeros([3, nct])

        # Compute energy relase rate of all crack tips
        for j, idx in enumerate(ict):
            # Solution at crack tip
            z = self.z(li[idx], C[:, [idx]], li[idx], phi, bed=ki[idx])
            # Mode I and II differential energy release rates
            Gdif[1:, j] = self.Gi(z, unit=unit), self.Gii(z, unit=unit)

        # Sum mode I and II contributions
        Gdif[0, :] = Gdif[1, :] + Gdif[2, :]

        # Adjust contributions for center cracks
        if nct &gt; 1:
            avgmask = np.full(nct, True)    # Initialize mask
            avgmask[[0, -1]] = ki[[0, -1]]  # Do not weight edge cracks
            Gdif[:, avgmask] *= 0.5         # Weigth with half crack length

        # Return total differential energy release rate of all crack tips
        return Gdif.sum(axis=1)

    def get_zmesh(self, dz=2):
        &#34;&#34;&#34;
        Get z-coordinates of grid points and corresponding elastic properties.

        Arguments
        ---------
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.

        Returns
        -------
        mesh : ndarray
            Mesh along z-axis. Columns are a list of z-coordinates (mm) of
            grid points along z-axis with at least two grid points (top,
            bottom) per layer, Young&#39;s modulus of each grid point, shear
            modulus of each grid point, and Poisson&#39;s ratio of each grid
            point.
        &#34;&#34;&#34;
        # Get ply (layer) coordinates
        z = self.get_ply_coordinates()
        # Compute number of grid points per layer
        nlayer = np.ceil((z[1:] - z[:-1])/dz).astype(np.int32) + 1
        # Calculate grid points as list of z-coordinates (mm)
        zi = np.hstack([
            np.linspace(z[i], z[i + 1], n, endpoint=True)
            for i, n in enumerate(nlayer)
        ])
        # Get lists of corresponding elastic properties (E, nu, rho)
        si = np.repeat(self.slab[:, [2, 4, 0]], nlayer, axis=0)
        # Assemble mesh with columns (z, E, G, nu)
        return np.column_stack([zi, si])

    def Sxx(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
        &#34;&#34;&#34;
        Compute axial normal stress in slab layers.

        Arguments
        ----------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.

        Returns
        -------
        ndarray, float
            Axial slab normal stress in specified unit.
        &#34;&#34;&#34;
        # Unit conversion dict
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }

        # Get mesh along z-axis
        zmesh = self.get_zmesh(dz=dz)
        zi = zmesh[:, 0]
        rho = 1e-12*zmesh[:, 3]

        # Get dimensions of stress field (n rows, m columns)
        n = zmesh.shape[0]
        m = Z.shape[1]

        # Initialize axial normal stress Sxx
        Sxx = np.zeros(shape=[n, m])

        # Compute axial normal stress Sxx at grid points in MPa
        for i, (z, E, nu, _) in enumerate(zmesh):
            Sxx[i, :] = E/(1-nu**2)*self.du_dx(Z, z)

        # Calculate weight load at grid points and superimpose on stress field
        qt = -rho*self.g*np.sin(np.deg2rad(phi))
        for i, qi in enumerate(qt[:-1]):
            Sxx[i, :] += qi*(zi[i+1] - zi[i])
        Sxx[-1, :] += qt[-1]*(zi[-1] - zi[-2])

        # Return axial normal stress in specified unit
        return convert[unit]*Sxx

    def Txz(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
        &#34;&#34;&#34;
        Compute shear stress in slab layers.

        Arguments
        ----------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.

        Returns
        -------
        ndarray
            Shear stress at grid points in the slab in specified unit.
        &#34;&#34;&#34;
        # Unit conversion dict
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }
        # Get mesh along z-axis
        zmesh = self.get_zmesh(dz=dz)
        zi = zmesh[:, 0]
        rho = 1e-12*zmesh[:, 3]

        # Get dimensions of stress field (n rows, m columns)
        n = zmesh.shape[0]
        m = Z.shape[1]

        # Get second derivatives of centerline displacement u0 and
        # cross-section rotaiton psi of all grid points along the x-axis
        du0_dxdx = self.du0_dxdx(Z, phi)
        dpsi_dxdx = self.dpsi_dxdx(Z, phi)

        # Initialize first derivative of axial normal stress sxx w.r.t. x
        dsxx_dx = np.zeros(shape=[n, m])

        # Calculate first derivative of sxx at z-grid points
        for i, (z, E, nu, _) in enumerate(zmesh):
            dsxx_dx[i, :] = E/(1-nu**2)*(du0_dxdx + z*dpsi_dxdx)

        # Calculate weight load at grid points
        qt = -rho*self.g*np.sin(np.deg2rad(phi))

        # Integrate -dsxx_dx along z and add cumulative weight load
        # to obtain shear stress Txz in MPa
        Txz = cumulative_trapezoid(dsxx_dx, zi, axis=0, initial=0)
        Txz += cumulative_trapezoid(qt, zi, initial=0)[:, None]

        # Return shear stress Txz in specified unit
        return convert[unit]*Txz

    def Szz(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
        &#34;&#34;&#34;
        Compute transverse normal stress in slab layers.

        Arguments
        ----------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.

        Returns
        -------
        ndarray, float
            Transverse normal stress at grid points in the slab in
            specified unit.
        &#34;&#34;&#34;
        # Unit conversion dict
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }

        # Get mesh along z-axis
        zmesh = self.get_zmesh(dz=dz)
        zi = zmesh[:, 0]
        rho = 1e-12*zmesh[:, 3]

        # Get dimensions of stress field (n rows, m columns)
        n = zmesh.shape[0]
        m = Z.shape[1]

        # Get third derivatives of centerline displacement u0 and
        # cross-section rotaiton psi of all grid points along the x-axis
        du0_dxdxdx = self.du0_dxdxdx(Z, phi)
        dpsi_dxdxdx = self.dpsi_dxdxdx(Z, phi)

        # Initialize second derivative of axial normal stress sxx w.r.t. x
        dsxx_dxdx = np.zeros(shape=[n, m])

        # Calculate second derivative of sxx at z-grid points
        for i, (z, E, nu, _) in enumerate(zmesh):
            dsxx_dxdx[i, :] = E/(1-nu**2)*(du0_dxdxdx + z*dpsi_dxdxdx)

        # Calculate weight load at grid points
        qn = rho*self.g*np.cos(np.deg2rad(phi))

        # Integrate dsxx_dxdx twice along z to obtain transverse
        # normal stress Szz in MPa
        integrand = cumulative_trapezoid(dsxx_dxdx, zi, axis=0, initial=0)
        Szz = cumulative_trapezoid(integrand, zi, axis=0, initial=0)
        Szz += cumulative_trapezoid(-qn, zi, initial=0)[:, None]

        # Return shear stress txz in specified unit
        return convert[unit]*Szz

    def principal_stress_slab(self, Z, phi, dz=2, unit=&#39;kPa&#39;,
                              val=&#39;max&#39;, normalize=False):
        &#34;&#34;&#34;
        Compute maxium or minimum principal stress in slab layers.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.
        val : str, optional
            Maximum &#39;max&#39; or minimum &#39;min&#39; principal stress. Default is &#39;max&#39;.
        normalize : bool
            Toggle layerwise normalization to strength.

        Returns
        -------
        ndarray
            Maximum or minimum principal stress in specified unit.

        Raises
        ------
        ValueError
            If specified principal stress component is neither &#39;max&#39; nor
            &#39;min&#39;, or if normalization of compressive principal stress
            is requested.
        &#34;&#34;&#34;
        # Raise error if specified component is not available
        if val not in [&#39;min&#39;, &#39;max&#39;]:
            raise ValueError(f&#39;Component {val} not defined.&#39;)

        # Multiplier selection dict
        m = {&#39;max&#39;: 1, &#39;min&#39;: -1}

        # Get axial normal stresses, shear stresses, transverse normal stresses
        Sxx = self.Sxx(Z=Z, phi=phi, dz=dz, unit=unit)
        Txz = self.Txz(Z=Z, phi=phi, dz=dz, unit=unit)
        Szz = self.Szz(Z=Z, phi=phi, dz=dz, unit=unit)

        # Calculate principal stress
        Ps = (Sxx + Szz)/2 + m[val]*np.sqrt((Sxx - Szz)**2 + 4*Txz**2)/2

        # Raise error if normalization of compressive stresses is attempted
        if normalize and val == &#39;min&#39;:
            raise ValueError(&#39;Can only normlize tensile stresses.&#39;)

        # Normalize tensile stresses to tensile strength
        if normalize and val == &#39;max&#39;:
            # Get layer densities
            rho = self.get_zmesh(dz=dz)[:, 3]
            # Normlize maximum principal stress to layers&#39; tensile strength
            return Ps/tensile_strength_slab(rho, unit=unit)[:, None]

        # Return absolute principal stresses
        return Ps

    def principal_stress_weaklayer(self, Z, sc=2.6, unit=&#39;kPa&#39;, val=&#39;min&#39;,
                                   normalize=False):
        &#34;&#34;&#34;
        Compute maxium or minimum principal stress in the weak layer.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        sc : float
            Weak-layer compressive strength. Default is 2.6 kPa.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.
        val : str, optional
            Maximum &#39;max&#39; or minimum &#39;min&#39; principal stress. Default is &#39;min&#39;.
        normalize : bool
            Toggle layerwise normalization to strength.

        Returns
        -------
        ndarray
            Maximum or minimum principal stress in specified unit.

        Raises
        ------
        ValueError
            If specified principal stress component is neither &#39;max&#39; nor
            &#39;min&#39;, or if normalization of tensile principal stress
            is requested.
        &#34;&#34;&#34;
        # Raise error if specified component is not available
        if val not in [&#39;min&#39;, &#39;max&#39;]:
            raise ValueError(f&#39;Component {val} not defined.&#39;)

        # Multiplier selection dict
        m = {&#39;max&#39;: 1, &#39;min&#39;: -1}

        # Get weak-layer normal and shear stresses
        sig = self.sig(Z, unit=unit)
        tau = self.tau(Z, unit=unit)

        # Calculate principal stress
        ps = sig/2 + m[val]*np.sqrt(sig**2 + 4*tau**2)/2

        # Raise error if normalization of tensile stresses is attempted
        if normalize and val == &#39;max&#39;:
            raise ValueError(&#39;Can only normlize compressive stresses.&#39;)

        # Normalize compressive stresses to compressive strength
        if normalize and val == &#39;min&#39;:
            return ps/sc

        # Return absolute principal stresses
        return ps

class OutputMixin:
    &#34;&#34;&#34;
    Mixin for outputs.

    Provides convenience methods for the assembly of output lists
    such as rasterized displacements or rasterized stresses.
    &#34;&#34;&#34;

    def get_weaklayer_shearstress(self, x, z, unit=&#39;MPa&#39;, removeNaNs=False):
        &#34;&#34;&#34;
        Compute weak-layer shear stress.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of unsupported
            (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
        unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
            Stress output unit. Default is MPa.
        keepNaNs : bool
            If set, do not remove

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        sig : ndarray
            Normal stress (stress unit input).
        &#34;&#34;&#34;
        # Convert coordinates from mm to cm and stresses from MPa to unit
        x = x/10
        tau = self.tau(z, unit=unit)
        # Filter stresses in unspupported segments
        if removeNaNs:
            # Remove coordinate-stress pairs where no weak layer is present
            tau = tau[~np.isnan(x)]
            x = x[~np.isnan(x)]
        else:
            # Set stress NaN where no weak layer is present
            tau[np.isnan(x)] = np.nan

        return x, tau

    def get_weaklayer_normalstress(self, x, z, unit=&#39;MPa&#39;, removeNaNs=False):
        &#34;&#34;&#34;
        Compute weak-layer normal stress.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of unsupported
            (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
        unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
            Stress output unit. Default is MPa.
        keepNaNs : bool
            If set, do not remove

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        sig : ndarray
            Normal stress (stress unit input).
        &#34;&#34;&#34;
        # Convert coordinates from mm to cm and stresses from MPa to unit
        x = x/10
        sig = self.sig(z, unit=unit)
        # Filter stresses in unspupported segments
        if removeNaNs:
            # Remove coordinate-stress pairs where no weak layer is present
            sig = sig[~np.isnan(x)]
            x = x[~np.isnan(x)]
        else:
            # Set stress NaN where no weak layer is present
            sig[np.isnan(x)] = np.nan

        return x, sig

    def get_slab_displacement(self, x, z, loc=&#39;mid&#39;, unit=&#39;mm&#39;):
        &#34;&#34;&#34;
        Compute horizontal slab displacement.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of
            unsupported (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
        loc : {&#39;top&#39;, &#39;mid&#39;, &#39;bot&#39;}
            Get displacements of top, midplane or bottom of slab.
            Default is mid.
        unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
            Displacement output unit. Default is mm.

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        ndarray
            Horizontal displacements (unit input).
        &#34;&#34;&#34;
        # Coordinates (cm)
        x = x/10
        # Locator
        z0 = {&#39;top&#39;: -self.h/2, &#39;mid&#39;: 0, &#39;bot&#39;: self.h/2}
        # Displacement (unit)
        u = self.u(z, z0=z0[loc], unit=unit)
        # Output array
        return x, u

    def get_slab_deflection(self, x, z, unit=&#39;mm&#39;):
        &#34;&#34;&#34;
        Compute vertical slab displacement.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of
            unsupported (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
            Default is mid.
        unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
            Displacement output unit. Default is mm.

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        ndarray
            Vertical deflections (unit input).
        &#34;&#34;&#34;
        # Coordinates (cm)
        x = x/10
        # Deflection (unit)
        w = self.w(z, unit=unit)
        # Output array
        return x, w

    def get_slab_rotation(self, x, z, unit=&#39;degrees&#39;):
        &#34;&#34;&#34;
        Compute slab cross-section rotation angle.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of
            unsupported (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
            Default is mid.
        unit : {&#39;deg&#39;, degrees&#39;, &#39;rad&#39;, &#39;radians&#39;}, optional
            Rotation angle output unit. Default is degrees.

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        ndarray
            Cross section rotations (unit input).
        &#34;&#34;&#34;
        # Coordinates (cm)
        x = x/10
        # Cross-section rotation angle (unit)
        psi = self.psi(z, unit=unit)
        # Output array
        return x, psi</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="weac.mixins.AnalysisMixin"><code class="flex name class">
<span>class <span class="ident">AnalysisMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for the analysis of model outputs.</p>
<p>Provides methods for the analysis of layered slabs on compliant
elastic foundations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalysisMixin:
    &#34;&#34;&#34;
    Mixin for the analysis of model outputs.

    Provides methods for the analysis of layered slabs on compliant
    elastic foundations.
    &#34;&#34;&#34;

    def rasterize_solution(self, C, phi, li, ki, num=250, **kwargs):
        &#34;&#34;&#34;
        Compute rasterized solution vector.

        Arguments
        ---------
        C : ndarray
            Vector of free constants.
        phi : float
            Inclination (degrees).
        li : ndarray
            List of segment lengths (mm).
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not.
        num : int
            Number of grid points.

        Returns
        -------
        xq : ndarray
            Grid point x-coordinates at which solution vector
            is discretized.
        zq : ndarray
            Matrix with solution vectors as colums at grid
            points xq.
        xb : ndarray
            Grid point x-coordinates that lie on a foundation.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Drop zero-length segments
        isnonzero = li &gt; 0
        C, ki, li = C[:, isnonzero], ki[isnonzero], li[isnonzero]

        # Compute number of plot points per segment (+1 for last segment)
        nq = np.ceil(li/li.sum()*num).astype(&#39;int&#39;)
        nq[-1] += 1

        # Provide cumulated length and plot point lists
        lic = np.insert(np.cumsum(li), 0, 0)
        nqc = np.insert(np.cumsum(nq), 0, 0)

        # Initialize arrays
        issupported = np.full(nq.sum(), True)
        xq = np.full(nq.sum(), np.nan)
        zq = np.full([6, xq.size], np.nan)

        # Loop through segments
        for i, l in enumerate(li):
            # Get local x-coordinates of segment i
            xi = np.linspace(0, l, num=nq[i], endpoint=(i == li.size - 1))
            # Compute start and end coordinates of segment i
            x0 = lic[i]
            # Assemble global coordinate vector
            xq[nqc[i]:nqc[i + 1]] = x0 + xi
            # Mask coordinates not on foundation (including endpoints)
            if not ki[i]:
                issupported[nqc[i]:nqc[i + 1]] = False
            # Compute segment solution
            zi = self.z(xi, C[:, [i]], l, phi, ki[i])
            # Assemble global solution matrix
            zq[:, nqc[i]:nqc[i + 1]] = zi

        # Make sure cracktips are included
        transmissionbool = [ki[j] or ki[j + 1] for j, _ in enumerate(ki[:-1])]
        for i, truefalse in enumerate(transmissionbool, start=1):
            issupported[nqc[i]] = truefalse

        # Assemble vector of coordinates on foundation
        xb = np.full(nq.sum(), np.nan)
        xb[issupported] = xq[issupported]

        return xq, zq, xb

    def ginc(self, C0, C1, phi, li, ki, k0, **kwargs):
        &#34;&#34;&#34;
        Compute incremental energy relase rate of of all cracks.

        Arguments
        ---------
        C0 : ndarray
            Free constants of uncracked solution.
        C1 : ndarray
            Free constants of cracked solution.
        phi : float
            Inclination (degress).
        li : ndarray
            List of segment lengths.
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the cracked configuration.
        k0 : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the uncracked configuration.

        Returns
        -------
        ndarray
            List of total, mode I, and mode II energy release rates.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Make sure inputs are np.arrays
        li, ki, k0 = np.array(li), np.array(ki), np.array(k0)

        # Reduce inputs to segments with crack advance
        iscrack = k0 &amp; ~ki
        C0, C1, li = C0[:, iscrack], C1[:, iscrack], li[iscrack]

        # Compute total crack lenght and initialize outputs
        da = li.sum() if li.sum() &gt; 0 else np.nan
        Ginc1, Ginc2 = 0, 0

        # Loop through segments with crack advance
        for j, l in enumerate(li):

            # Uncracked (0) and cracked (1) solutions at integration points
            z0 = partial(self.z, C=C0[:, [j]], l=l, phi=phi, bed=True)
            z1 = partial(self.z, C=C1[:, [j]], l=l, phi=phi, bed=False)

            # Mode I (1) and II (2) integrands at integration points
            int1 = partial(self.int1, z0=z0, z1=z1)
            int2 = partial(self.int2, z0=z0, z1=z1)

            # Segement contributions to total crack opening integral
            Ginc1 += romberg(int1, 0, l, rtol=self.tol,
                             vec_func=True)/(2*da)
            Ginc2 += romberg(int2, 0, l, rtol=self.tol,
                             vec_func=True)/(2*da)

        return np.array([Ginc1 + Ginc2, Ginc1, Ginc2]).flatten()

    def gdif(self, C, phi, li, ki, unit=&#39;kJ/m^2&#39;, **kwargs):
        &#34;&#34;&#34;
        Compute differential energy release rate of all crack tips.

        Arguments
        ---------
        C : ndarray
            Free constants of the solution.
        phi : float
            Inclination (degress).
        li : ndarray
            List of segment lengths.
        ki : ndarray
            List of booleans indicating whether segment lies on
            a foundation or not in the cracked configuration.

        Returns
        -------
        ndarray
            List of total, mode I, and mode II energy release rates.
        &#34;&#34;&#34;
        # Unused arguments
        _ = kwargs

        # Get number and indices of segment transitions
        ntr = len(li) - 1
        itr = np.arange(ntr)

        # Identify supported-free and free-supported transitions as crack tips
        iscracktip = [ki[j] != ki[j + 1] for j in range(ntr)]

        # Transition indices of crack tips and total number of crack tips
        ict = itr[iscracktip]
        nct = len(ict)

        # Initialize energy release rate array
        Gdif = np.zeros([3, nct])

        # Compute energy relase rate of all crack tips
        for j, idx in enumerate(ict):
            # Solution at crack tip
            z = self.z(li[idx], C[:, [idx]], li[idx], phi, bed=ki[idx])
            # Mode I and II differential energy release rates
            Gdif[1:, j] = self.Gi(z, unit=unit), self.Gii(z, unit=unit)

        # Sum mode I and II contributions
        Gdif[0, :] = Gdif[1, :] + Gdif[2, :]

        # Adjust contributions for center cracks
        if nct &gt; 1:
            avgmask = np.full(nct, True)    # Initialize mask
            avgmask[[0, -1]] = ki[[0, -1]]  # Do not weight edge cracks
            Gdif[:, avgmask] *= 0.5         # Weigth with half crack length

        # Return total differential energy release rate of all crack tips
        return Gdif.sum(axis=1)

    def get_zmesh(self, dz=2):
        &#34;&#34;&#34;
        Get z-coordinates of grid points and corresponding elastic properties.

        Arguments
        ---------
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.

        Returns
        -------
        mesh : ndarray
            Mesh along z-axis. Columns are a list of z-coordinates (mm) of
            grid points along z-axis with at least two grid points (top,
            bottom) per layer, Young&#39;s modulus of each grid point, shear
            modulus of each grid point, and Poisson&#39;s ratio of each grid
            point.
        &#34;&#34;&#34;
        # Get ply (layer) coordinates
        z = self.get_ply_coordinates()
        # Compute number of grid points per layer
        nlayer = np.ceil((z[1:] - z[:-1])/dz).astype(np.int32) + 1
        # Calculate grid points as list of z-coordinates (mm)
        zi = np.hstack([
            np.linspace(z[i], z[i + 1], n, endpoint=True)
            for i, n in enumerate(nlayer)
        ])
        # Get lists of corresponding elastic properties (E, nu, rho)
        si = np.repeat(self.slab[:, [2, 4, 0]], nlayer, axis=0)
        # Assemble mesh with columns (z, E, G, nu)
        return np.column_stack([zi, si])

    def Sxx(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
        &#34;&#34;&#34;
        Compute axial normal stress in slab layers.

        Arguments
        ----------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.

        Returns
        -------
        ndarray, float
            Axial slab normal stress in specified unit.
        &#34;&#34;&#34;
        # Unit conversion dict
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }

        # Get mesh along z-axis
        zmesh = self.get_zmesh(dz=dz)
        zi = zmesh[:, 0]
        rho = 1e-12*zmesh[:, 3]

        # Get dimensions of stress field (n rows, m columns)
        n = zmesh.shape[0]
        m = Z.shape[1]

        # Initialize axial normal stress Sxx
        Sxx = np.zeros(shape=[n, m])

        # Compute axial normal stress Sxx at grid points in MPa
        for i, (z, E, nu, _) in enumerate(zmesh):
            Sxx[i, :] = E/(1-nu**2)*self.du_dx(Z, z)

        # Calculate weight load at grid points and superimpose on stress field
        qt = -rho*self.g*np.sin(np.deg2rad(phi))
        for i, qi in enumerate(qt[:-1]):
            Sxx[i, :] += qi*(zi[i+1] - zi[i])
        Sxx[-1, :] += qt[-1]*(zi[-1] - zi[-2])

        # Return axial normal stress in specified unit
        return convert[unit]*Sxx

    def Txz(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
        &#34;&#34;&#34;
        Compute shear stress in slab layers.

        Arguments
        ----------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.

        Returns
        -------
        ndarray
            Shear stress at grid points in the slab in specified unit.
        &#34;&#34;&#34;
        # Unit conversion dict
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }
        # Get mesh along z-axis
        zmesh = self.get_zmesh(dz=dz)
        zi = zmesh[:, 0]
        rho = 1e-12*zmesh[:, 3]

        # Get dimensions of stress field (n rows, m columns)
        n = zmesh.shape[0]
        m = Z.shape[1]

        # Get second derivatives of centerline displacement u0 and
        # cross-section rotaiton psi of all grid points along the x-axis
        du0_dxdx = self.du0_dxdx(Z, phi)
        dpsi_dxdx = self.dpsi_dxdx(Z, phi)

        # Initialize first derivative of axial normal stress sxx w.r.t. x
        dsxx_dx = np.zeros(shape=[n, m])

        # Calculate first derivative of sxx at z-grid points
        for i, (z, E, nu, _) in enumerate(zmesh):
            dsxx_dx[i, :] = E/(1-nu**2)*(du0_dxdx + z*dpsi_dxdx)

        # Calculate weight load at grid points
        qt = -rho*self.g*np.sin(np.deg2rad(phi))

        # Integrate -dsxx_dx along z and add cumulative weight load
        # to obtain shear stress Txz in MPa
        Txz = cumulative_trapezoid(dsxx_dx, zi, axis=0, initial=0)
        Txz += cumulative_trapezoid(qt, zi, initial=0)[:, None]

        # Return shear stress Txz in specified unit
        return convert[unit]*Txz

    def Szz(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
        &#34;&#34;&#34;
        Compute transverse normal stress in slab layers.

        Arguments
        ----------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.

        Returns
        -------
        ndarray, float
            Transverse normal stress at grid points in the slab in
            specified unit.
        &#34;&#34;&#34;
        # Unit conversion dict
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }

        # Get mesh along z-axis
        zmesh = self.get_zmesh(dz=dz)
        zi = zmesh[:, 0]
        rho = 1e-12*zmesh[:, 3]

        # Get dimensions of stress field (n rows, m columns)
        n = zmesh.shape[0]
        m = Z.shape[1]

        # Get third derivatives of centerline displacement u0 and
        # cross-section rotaiton psi of all grid points along the x-axis
        du0_dxdxdx = self.du0_dxdxdx(Z, phi)
        dpsi_dxdxdx = self.dpsi_dxdxdx(Z, phi)

        # Initialize second derivative of axial normal stress sxx w.r.t. x
        dsxx_dxdx = np.zeros(shape=[n, m])

        # Calculate second derivative of sxx at z-grid points
        for i, (z, E, nu, _) in enumerate(zmesh):
            dsxx_dxdx[i, :] = E/(1-nu**2)*(du0_dxdxdx + z*dpsi_dxdxdx)

        # Calculate weight load at grid points
        qn = rho*self.g*np.cos(np.deg2rad(phi))

        # Integrate dsxx_dxdx twice along z to obtain transverse
        # normal stress Szz in MPa
        integrand = cumulative_trapezoid(dsxx_dxdx, zi, axis=0, initial=0)
        Szz = cumulative_trapezoid(integrand, zi, axis=0, initial=0)
        Szz += cumulative_trapezoid(-qn, zi, initial=0)[:, None]

        # Return shear stress txz in specified unit
        return convert[unit]*Szz

    def principal_stress_slab(self, Z, phi, dz=2, unit=&#39;kPa&#39;,
                              val=&#39;max&#39;, normalize=False):
        &#34;&#34;&#34;
        Compute maxium or minimum principal stress in slab layers.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.
        dz : float, optional
            Element size along z-axis (mm). Default is 2 mm.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.
        val : str, optional
            Maximum &#39;max&#39; or minimum &#39;min&#39; principal stress. Default is &#39;max&#39;.
        normalize : bool
            Toggle layerwise normalization to strength.

        Returns
        -------
        ndarray
            Maximum or minimum principal stress in specified unit.

        Raises
        ------
        ValueError
            If specified principal stress component is neither &#39;max&#39; nor
            &#39;min&#39;, or if normalization of compressive principal stress
            is requested.
        &#34;&#34;&#34;
        # Raise error if specified component is not available
        if val not in [&#39;min&#39;, &#39;max&#39;]:
            raise ValueError(f&#39;Component {val} not defined.&#39;)

        # Multiplier selection dict
        m = {&#39;max&#39;: 1, &#39;min&#39;: -1}

        # Get axial normal stresses, shear stresses, transverse normal stresses
        Sxx = self.Sxx(Z=Z, phi=phi, dz=dz, unit=unit)
        Txz = self.Txz(Z=Z, phi=phi, dz=dz, unit=unit)
        Szz = self.Szz(Z=Z, phi=phi, dz=dz, unit=unit)

        # Calculate principal stress
        Ps = (Sxx + Szz)/2 + m[val]*np.sqrt((Sxx - Szz)**2 + 4*Txz**2)/2

        # Raise error if normalization of compressive stresses is attempted
        if normalize and val == &#39;min&#39;:
            raise ValueError(&#39;Can only normlize tensile stresses.&#39;)

        # Normalize tensile stresses to tensile strength
        if normalize and val == &#39;max&#39;:
            # Get layer densities
            rho = self.get_zmesh(dz=dz)[:, 3]
            # Normlize maximum principal stress to layers&#39; tensile strength
            return Ps/tensile_strength_slab(rho, unit=unit)[:, None]

        # Return absolute principal stresses
        return Ps

    def principal_stress_weaklayer(self, Z, sc=2.6, unit=&#39;kPa&#39;, val=&#39;min&#39;,
                                   normalize=False):
        &#34;&#34;&#34;
        Compute maxium or minimum principal stress in the weak layer.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        sc : float
            Weak-layer compressive strength. Default is 2.6 kPa.
        unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
            Desired output unit. Default is &#39;kPa&#39;.
        val : str, optional
            Maximum &#39;max&#39; or minimum &#39;min&#39; principal stress. Default is &#39;min&#39;.
        normalize : bool
            Toggle layerwise normalization to strength.

        Returns
        -------
        ndarray
            Maximum or minimum principal stress in specified unit.

        Raises
        ------
        ValueError
            If specified principal stress component is neither &#39;max&#39; nor
            &#39;min&#39;, or if normalization of tensile principal stress
            is requested.
        &#34;&#34;&#34;
        # Raise error if specified component is not available
        if val not in [&#39;min&#39;, &#39;max&#39;]:
            raise ValueError(f&#39;Component {val} not defined.&#39;)

        # Multiplier selection dict
        m = {&#39;max&#39;: 1, &#39;min&#39;: -1}

        # Get weak-layer normal and shear stresses
        sig = self.sig(Z, unit=unit)
        tau = self.tau(Z, unit=unit)

        # Calculate principal stress
        ps = sig/2 + m[val]*np.sqrt(sig**2 + 4*tau**2)/2

        # Raise error if normalization of tensile stresses is attempted
        if normalize and val == &#39;max&#39;:
            raise ValueError(&#39;Can only normlize compressive stresses.&#39;)

        # Normalize compressive stresses to compressive strength
        if normalize and val == &#39;min&#39;:
            return ps/sc

        # Return absolute principal stresses
        return ps</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weac.inverse.Inverse" href="inverse.html#weac.inverse.Inverse">Inverse</a></li>
<li><a title="weac.layered.Layered" href="layered.html#weac.layered.Layered">Layered</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="weac.mixins.AnalysisMixin.Sxx"><code class="name flex">
<span>def <span class="ident">Sxx</span></span>(<span>self, Z, phi, dz=2, unit='kPa')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute axial normal stress in slab layers.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x), psi'(x)]^T</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Element size along z-axis (mm). Default is 2 mm.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'kPa', 'MPa'}</code>, optional</dt>
<dd>Desired output unit. Default is 'kPa'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray, float</code></dt>
<dd>Axial slab normal stress in specified unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Sxx(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
    &#34;&#34;&#34;
    Compute axial normal stress in slab layers.

    Arguments
    ----------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
    phi : float
        Inclination (degrees). Counterclockwise positive.
    dz : float, optional
        Element size along z-axis (mm). Default is 2 mm.
    unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
        Desired output unit. Default is &#39;kPa&#39;.

    Returns
    -------
    ndarray, float
        Axial slab normal stress in specified unit.
    &#34;&#34;&#34;
    # Unit conversion dict
    convert = {
        &#39;kPa&#39;: 1e3,
        &#39;MPa&#39;: 1
    }

    # Get mesh along z-axis
    zmesh = self.get_zmesh(dz=dz)
    zi = zmesh[:, 0]
    rho = 1e-12*zmesh[:, 3]

    # Get dimensions of stress field (n rows, m columns)
    n = zmesh.shape[0]
    m = Z.shape[1]

    # Initialize axial normal stress Sxx
    Sxx = np.zeros(shape=[n, m])

    # Compute axial normal stress Sxx at grid points in MPa
    for i, (z, E, nu, _) in enumerate(zmesh):
        Sxx[i, :] = E/(1-nu**2)*self.du_dx(Z, z)

    # Calculate weight load at grid points and superimpose on stress field
    qt = -rho*self.g*np.sin(np.deg2rad(phi))
    for i, qi in enumerate(qt[:-1]):
        Sxx[i, :] += qi*(zi[i+1] - zi[i])
    Sxx[-1, :] += qt[-1]*(zi[-1] - zi[-2])

    # Return axial normal stress in specified unit
    return convert[unit]*Sxx</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.Szz"><code class="name flex">
<span>def <span class="ident">Szz</span></span>(<span>self, Z, phi, dz=2, unit='kPa')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute transverse normal stress in slab layers.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x), psi'(x)]^T</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Element size along z-axis (mm). Default is 2 mm.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'kPa', 'MPa'}</code>, optional</dt>
<dd>Desired output unit. Default is 'kPa'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray, float</code></dt>
<dd>Transverse normal stress at grid points in the slab in
specified unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Szz(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
    &#34;&#34;&#34;
    Compute transverse normal stress in slab layers.

    Arguments
    ----------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
    phi : float
        Inclination (degrees). Counterclockwise positive.
    dz : float, optional
        Element size along z-axis (mm). Default is 2 mm.
    unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
        Desired output unit. Default is &#39;kPa&#39;.

    Returns
    -------
    ndarray, float
        Transverse normal stress at grid points in the slab in
        specified unit.
    &#34;&#34;&#34;
    # Unit conversion dict
    convert = {
        &#39;kPa&#39;: 1e3,
        &#39;MPa&#39;: 1
    }

    # Get mesh along z-axis
    zmesh = self.get_zmesh(dz=dz)
    zi = zmesh[:, 0]
    rho = 1e-12*zmesh[:, 3]

    # Get dimensions of stress field (n rows, m columns)
    n = zmesh.shape[0]
    m = Z.shape[1]

    # Get third derivatives of centerline displacement u0 and
    # cross-section rotaiton psi of all grid points along the x-axis
    du0_dxdxdx = self.du0_dxdxdx(Z, phi)
    dpsi_dxdxdx = self.dpsi_dxdxdx(Z, phi)

    # Initialize second derivative of axial normal stress sxx w.r.t. x
    dsxx_dxdx = np.zeros(shape=[n, m])

    # Calculate second derivative of sxx at z-grid points
    for i, (z, E, nu, _) in enumerate(zmesh):
        dsxx_dxdx[i, :] = E/(1-nu**2)*(du0_dxdxdx + z*dpsi_dxdxdx)

    # Calculate weight load at grid points
    qn = rho*self.g*np.cos(np.deg2rad(phi))

    # Integrate dsxx_dxdx twice along z to obtain transverse
    # normal stress Szz in MPa
    integrand = cumulative_trapezoid(dsxx_dxdx, zi, axis=0, initial=0)
    Szz = cumulative_trapezoid(integrand, zi, axis=0, initial=0)
    Szz += cumulative_trapezoid(-qn, zi, initial=0)[:, None]

    # Return shear stress txz in specified unit
    return convert[unit]*Szz</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.Txz"><code class="name flex">
<span>def <span class="ident">Txz</span></span>(<span>self, Z, phi, dz=2, unit='kPa')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute shear stress in slab layers.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x), psi'(x)]^T</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Element size along z-axis (mm). Default is 2 mm.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'kPa', 'MPa'}</code>, optional</dt>
<dd>Desired output unit. Default is 'kPa'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Shear stress at grid points in the slab in specified unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Txz(self, Z, phi, dz=2, unit=&#39;kPa&#39;):
    &#34;&#34;&#34;
    Compute shear stress in slab layers.

    Arguments
    ----------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
    phi : float
        Inclination (degrees). Counterclockwise positive.
    dz : float, optional
        Element size along z-axis (mm). Default is 2 mm.
    unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
        Desired output unit. Default is &#39;kPa&#39;.

    Returns
    -------
    ndarray
        Shear stress at grid points in the slab in specified unit.
    &#34;&#34;&#34;
    # Unit conversion dict
    convert = {
        &#39;kPa&#39;: 1e3,
        &#39;MPa&#39;: 1
    }
    # Get mesh along z-axis
    zmesh = self.get_zmesh(dz=dz)
    zi = zmesh[:, 0]
    rho = 1e-12*zmesh[:, 3]

    # Get dimensions of stress field (n rows, m columns)
    n = zmesh.shape[0]
    m = Z.shape[1]

    # Get second derivatives of centerline displacement u0 and
    # cross-section rotaiton psi of all grid points along the x-axis
    du0_dxdx = self.du0_dxdx(Z, phi)
    dpsi_dxdx = self.dpsi_dxdx(Z, phi)

    # Initialize first derivative of axial normal stress sxx w.r.t. x
    dsxx_dx = np.zeros(shape=[n, m])

    # Calculate first derivative of sxx at z-grid points
    for i, (z, E, nu, _) in enumerate(zmesh):
        dsxx_dx[i, :] = E/(1-nu**2)*(du0_dxdx + z*dpsi_dxdx)

    # Calculate weight load at grid points
    qt = -rho*self.g*np.sin(np.deg2rad(phi))

    # Integrate -dsxx_dx along z and add cumulative weight load
    # to obtain shear stress Txz in MPa
    Txz = cumulative_trapezoid(dsxx_dx, zi, axis=0, initial=0)
    Txz += cumulative_trapezoid(qt, zi, initial=0)[:, None]

    # Return shear stress Txz in specified unit
    return convert[unit]*Txz</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.gdif"><code class="name flex">
<span>def <span class="ident">gdif</span></span>(<span>self, C, phi, li, ki, unit='kJ/m^2', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute differential energy release rate of all crack tips.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Free constants of the solution.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degress).</dd>
<dt><strong><code>li</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of segment lengths.</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of booleans indicating whether segment lies on
a foundation or not in the cracked configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>List of total, mode I, and mode II energy release rates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gdif(self, C, phi, li, ki, unit=&#39;kJ/m^2&#39;, **kwargs):
    &#34;&#34;&#34;
    Compute differential energy release rate of all crack tips.

    Arguments
    ---------
    C : ndarray
        Free constants of the solution.
    phi : float
        Inclination (degress).
    li : ndarray
        List of segment lengths.
    ki : ndarray
        List of booleans indicating whether segment lies on
        a foundation or not in the cracked configuration.

    Returns
    -------
    ndarray
        List of total, mode I, and mode II energy release rates.
    &#34;&#34;&#34;
    # Unused arguments
    _ = kwargs

    # Get number and indices of segment transitions
    ntr = len(li) - 1
    itr = np.arange(ntr)

    # Identify supported-free and free-supported transitions as crack tips
    iscracktip = [ki[j] != ki[j + 1] for j in range(ntr)]

    # Transition indices of crack tips and total number of crack tips
    ict = itr[iscracktip]
    nct = len(ict)

    # Initialize energy release rate array
    Gdif = np.zeros([3, nct])

    # Compute energy relase rate of all crack tips
    for j, idx in enumerate(ict):
        # Solution at crack tip
        z = self.z(li[idx], C[:, [idx]], li[idx], phi, bed=ki[idx])
        # Mode I and II differential energy release rates
        Gdif[1:, j] = self.Gi(z, unit=unit), self.Gii(z, unit=unit)

    # Sum mode I and II contributions
    Gdif[0, :] = Gdif[1, :] + Gdif[2, :]

    # Adjust contributions for center cracks
    if nct &gt; 1:
        avgmask = np.full(nct, True)    # Initialize mask
        avgmask[[0, -1]] = ki[[0, -1]]  # Do not weight edge cracks
        Gdif[:, avgmask] *= 0.5         # Weigth with half crack length

    # Return total differential energy release rate of all crack tips
    return Gdif.sum(axis=1)</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.get_zmesh"><code class="name flex">
<span>def <span class="ident">get_zmesh</span></span>(<span>self, dz=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Get z-coordinates of grid points and corresponding elastic properties.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Element size along z-axis (mm). Default is 2 mm.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Mesh along z-axis. Columns are a list of z-coordinates (mm) of
grid points along z-axis with at least two grid points (top,
bottom) per layer, Young's modulus of each grid point, shear
modulus of each grid point, and Poisson's ratio of each grid
point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_zmesh(self, dz=2):
    &#34;&#34;&#34;
    Get z-coordinates of grid points and corresponding elastic properties.

    Arguments
    ---------
    dz : float, optional
        Element size along z-axis (mm). Default is 2 mm.

    Returns
    -------
    mesh : ndarray
        Mesh along z-axis. Columns are a list of z-coordinates (mm) of
        grid points along z-axis with at least two grid points (top,
        bottom) per layer, Young&#39;s modulus of each grid point, shear
        modulus of each grid point, and Poisson&#39;s ratio of each grid
        point.
    &#34;&#34;&#34;
    # Get ply (layer) coordinates
    z = self.get_ply_coordinates()
    # Compute number of grid points per layer
    nlayer = np.ceil((z[1:] - z[:-1])/dz).astype(np.int32) + 1
    # Calculate grid points as list of z-coordinates (mm)
    zi = np.hstack([
        np.linspace(z[i], z[i + 1], n, endpoint=True)
        for i, n in enumerate(nlayer)
    ])
    # Get lists of corresponding elastic properties (E, nu, rho)
    si = np.repeat(self.slab[:, [2, 4, 0]], nlayer, axis=0)
    # Assemble mesh with columns (z, E, G, nu)
    return np.column_stack([zi, si])</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.ginc"><code class="name flex">
<span>def <span class="ident">ginc</span></span>(<span>self, C0, C1, phi, li, ki, k0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute incremental energy relase rate of of all cracks.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>C0</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Free constants of uncracked solution.</dd>
<dt><strong><code>C1</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Free constants of cracked solution.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degress).</dd>
<dt><strong><code>li</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of segment lengths.</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of booleans indicating whether segment lies on
a foundation or not in the cracked configuration.</dd>
<dt><strong><code>k0</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of booleans indicating whether segment lies on
a foundation or not in the uncracked configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>List of total, mode I, and mode II energy release rates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ginc(self, C0, C1, phi, li, ki, k0, **kwargs):
    &#34;&#34;&#34;
    Compute incremental energy relase rate of of all cracks.

    Arguments
    ---------
    C0 : ndarray
        Free constants of uncracked solution.
    C1 : ndarray
        Free constants of cracked solution.
    phi : float
        Inclination (degress).
    li : ndarray
        List of segment lengths.
    ki : ndarray
        List of booleans indicating whether segment lies on
        a foundation or not in the cracked configuration.
    k0 : ndarray
        List of booleans indicating whether segment lies on
        a foundation or not in the uncracked configuration.

    Returns
    -------
    ndarray
        List of total, mode I, and mode II energy release rates.
    &#34;&#34;&#34;
    # Unused arguments
    _ = kwargs

    # Make sure inputs are np.arrays
    li, ki, k0 = np.array(li), np.array(ki), np.array(k0)

    # Reduce inputs to segments with crack advance
    iscrack = k0 &amp; ~ki
    C0, C1, li = C0[:, iscrack], C1[:, iscrack], li[iscrack]

    # Compute total crack lenght and initialize outputs
    da = li.sum() if li.sum() &gt; 0 else np.nan
    Ginc1, Ginc2 = 0, 0

    # Loop through segments with crack advance
    for j, l in enumerate(li):

        # Uncracked (0) and cracked (1) solutions at integration points
        z0 = partial(self.z, C=C0[:, [j]], l=l, phi=phi, bed=True)
        z1 = partial(self.z, C=C1[:, [j]], l=l, phi=phi, bed=False)

        # Mode I (1) and II (2) integrands at integration points
        int1 = partial(self.int1, z0=z0, z1=z1)
        int2 = partial(self.int2, z0=z0, z1=z1)

        # Segement contributions to total crack opening integral
        Ginc1 += romberg(int1, 0, l, rtol=self.tol,
                         vec_func=True)/(2*da)
        Ginc2 += romberg(int2, 0, l, rtol=self.tol,
                         vec_func=True)/(2*da)

    return np.array([Ginc1 + Ginc2, Ginc1, Ginc2]).flatten()</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.principal_stress_slab"><code class="name flex">
<span>def <span class="ident">principal_stress_slab</span></span>(<span>self, Z, phi, dz=2, unit='kPa', val='max', normalize=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute maxium or minimum principal stress in slab layers.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x), psi'(x)]^T</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Element size along z-axis (mm). Default is 2 mm.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'kPa', 'MPa'}</code>, optional</dt>
<dd>Desired output unit. Default is 'kPa'.</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Maximum 'max' or minimum 'min' principal stress. Default is 'max'.</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Toggle layerwise normalization to strength.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Maximum or minimum principal stress in specified unit.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If specified principal stress component is neither 'max' nor
'min', or if normalization of compressive principal stress
is requested.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def principal_stress_slab(self, Z, phi, dz=2, unit=&#39;kPa&#39;,
                          val=&#39;max&#39;, normalize=False):
    &#34;&#34;&#34;
    Compute maxium or minimum principal stress in slab layers.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
    phi : float
        Inclination (degrees). Counterclockwise positive.
    dz : float, optional
        Element size along z-axis (mm). Default is 2 mm.
    unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
        Desired output unit. Default is &#39;kPa&#39;.
    val : str, optional
        Maximum &#39;max&#39; or minimum &#39;min&#39; principal stress. Default is &#39;max&#39;.
    normalize : bool
        Toggle layerwise normalization to strength.

    Returns
    -------
    ndarray
        Maximum or minimum principal stress in specified unit.

    Raises
    ------
    ValueError
        If specified principal stress component is neither &#39;max&#39; nor
        &#39;min&#39;, or if normalization of compressive principal stress
        is requested.
    &#34;&#34;&#34;
    # Raise error if specified component is not available
    if val not in [&#39;min&#39;, &#39;max&#39;]:
        raise ValueError(f&#39;Component {val} not defined.&#39;)

    # Multiplier selection dict
    m = {&#39;max&#39;: 1, &#39;min&#39;: -1}

    # Get axial normal stresses, shear stresses, transverse normal stresses
    Sxx = self.Sxx(Z=Z, phi=phi, dz=dz, unit=unit)
    Txz = self.Txz(Z=Z, phi=phi, dz=dz, unit=unit)
    Szz = self.Szz(Z=Z, phi=phi, dz=dz, unit=unit)

    # Calculate principal stress
    Ps = (Sxx + Szz)/2 + m[val]*np.sqrt((Sxx - Szz)**2 + 4*Txz**2)/2

    # Raise error if normalization of compressive stresses is attempted
    if normalize and val == &#39;min&#39;:
        raise ValueError(&#39;Can only normlize tensile stresses.&#39;)

    # Normalize tensile stresses to tensile strength
    if normalize and val == &#39;max&#39;:
        # Get layer densities
        rho = self.get_zmesh(dz=dz)[:, 3]
        # Normlize maximum principal stress to layers&#39; tensile strength
        return Ps/tensile_strength_slab(rho, unit=unit)[:, None]

    # Return absolute principal stresses
    return Ps</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.principal_stress_weaklayer"><code class="name flex">
<span>def <span class="ident">principal_stress_weaklayer</span></span>(<span>self, Z, sc=2.6, unit='kPa', val='min', normalize=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute maxium or minimum principal stress in the weak layer.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x), psi'(x)]^T</dd>
<dt><strong><code>sc</code></strong> :&ensp;<code>float</code></dt>
<dd>Weak-layer compressive strength. Default is 2.6 kPa.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'kPa', 'MPa'}</code>, optional</dt>
<dd>Desired output unit. Default is 'kPa'.</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Maximum 'max' or minimum 'min' principal stress. Default is 'min'.</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Toggle layerwise normalization to strength.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Maximum or minimum principal stress in specified unit.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If specified principal stress component is neither 'max' nor
'min', or if normalization of tensile principal stress
is requested.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def principal_stress_weaklayer(self, Z, sc=2.6, unit=&#39;kPa&#39;, val=&#39;min&#39;,
                               normalize=False):
    &#34;&#34;&#34;
    Compute maxium or minimum principal stress in the weak layer.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
    sc : float
        Weak-layer compressive strength. Default is 2.6 kPa.
    unit : {&#39;kPa&#39;, &#39;MPa&#39;}, optional
        Desired output unit. Default is &#39;kPa&#39;.
    val : str, optional
        Maximum &#39;max&#39; or minimum &#39;min&#39; principal stress. Default is &#39;min&#39;.
    normalize : bool
        Toggle layerwise normalization to strength.

    Returns
    -------
    ndarray
        Maximum or minimum principal stress in specified unit.

    Raises
    ------
    ValueError
        If specified principal stress component is neither &#39;max&#39; nor
        &#39;min&#39;, or if normalization of tensile principal stress
        is requested.
    &#34;&#34;&#34;
    # Raise error if specified component is not available
    if val not in [&#39;min&#39;, &#39;max&#39;]:
        raise ValueError(f&#39;Component {val} not defined.&#39;)

    # Multiplier selection dict
    m = {&#39;max&#39;: 1, &#39;min&#39;: -1}

    # Get weak-layer normal and shear stresses
    sig = self.sig(Z, unit=unit)
    tau = self.tau(Z, unit=unit)

    # Calculate principal stress
    ps = sig/2 + m[val]*np.sqrt(sig**2 + 4*tau**2)/2

    # Raise error if normalization of tensile stresses is attempted
    if normalize and val == &#39;max&#39;:
        raise ValueError(&#39;Can only normlize compressive stresses.&#39;)

    # Normalize compressive stresses to compressive strength
    if normalize and val == &#39;min&#39;:
        return ps/sc

    # Return absolute principal stresses
    return ps</code></pre>
</details>
</dd>
<dt id="weac.mixins.AnalysisMixin.rasterize_solution"><code class="name flex">
<span>def <span class="ident">rasterize_solution</span></span>(<span>self, C, phi, li, ki, num=250, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute rasterized solution vector.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Vector of free constants.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees).</dd>
<dt><strong><code>li</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of segment lengths (mm).</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of booleans indicating whether segment lies on
a foundation or not.</dd>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of grid points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xq</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Grid point x-coordinates at which solution vector
is discretized.</dd>
<dt><strong><code>zq</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix with solution vectors as colums at grid
points xq.</dd>
<dt><strong><code>xb</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Grid point x-coordinates that lie on a foundation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rasterize_solution(self, C, phi, li, ki, num=250, **kwargs):
    &#34;&#34;&#34;
    Compute rasterized solution vector.

    Arguments
    ---------
    C : ndarray
        Vector of free constants.
    phi : float
        Inclination (degrees).
    li : ndarray
        List of segment lengths (mm).
    ki : ndarray
        List of booleans indicating whether segment lies on
        a foundation or not.
    num : int
        Number of grid points.

    Returns
    -------
    xq : ndarray
        Grid point x-coordinates at which solution vector
        is discretized.
    zq : ndarray
        Matrix with solution vectors as colums at grid
        points xq.
    xb : ndarray
        Grid point x-coordinates that lie on a foundation.
    &#34;&#34;&#34;
    # Unused arguments
    _ = kwargs

    # Drop zero-length segments
    isnonzero = li &gt; 0
    C, ki, li = C[:, isnonzero], ki[isnonzero], li[isnonzero]

    # Compute number of plot points per segment (+1 for last segment)
    nq = np.ceil(li/li.sum()*num).astype(&#39;int&#39;)
    nq[-1] += 1

    # Provide cumulated length and plot point lists
    lic = np.insert(np.cumsum(li), 0, 0)
    nqc = np.insert(np.cumsum(nq), 0, 0)

    # Initialize arrays
    issupported = np.full(nq.sum(), True)
    xq = np.full(nq.sum(), np.nan)
    zq = np.full([6, xq.size], np.nan)

    # Loop through segments
    for i, l in enumerate(li):
        # Get local x-coordinates of segment i
        xi = np.linspace(0, l, num=nq[i], endpoint=(i == li.size - 1))
        # Compute start and end coordinates of segment i
        x0 = lic[i]
        # Assemble global coordinate vector
        xq[nqc[i]:nqc[i + 1]] = x0 + xi
        # Mask coordinates not on foundation (including endpoints)
        if not ki[i]:
            issupported[nqc[i]:nqc[i + 1]] = False
        # Compute segment solution
        zi = self.z(xi, C[:, [i]], l, phi, ki[i])
        # Assemble global solution matrix
        zq[:, nqc[i]:nqc[i + 1]] = zi

    # Make sure cracktips are included
    transmissionbool = [ki[j] or ki[j + 1] for j, _ in enumerate(ki[:-1])]
    for i, truefalse in enumerate(transmissionbool, start=1):
        issupported[nqc[i]] = truefalse

    # Assemble vector of coordinates on foundation
    xb = np.full(nq.sum(), np.nan)
    xb[issupported] = xq[issupported]

    return xq, zq, xb</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin"><code class="flex name class">
<span>class <span class="ident">FieldQuantitiesMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for field quantities.</p>
<p>Provides methods for the computation of displacements, stresses,
strains, and energy release rates from the solution vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldQuantitiesMixin:
    &#34;&#34;&#34;
    Mixin for field quantities.

    Provides methods for the computation of displacements, stresses,
    strains, and energy release rates from the solution vector.
    &#34;&#34;&#34;

    # pylint: disable=no-self-use
    def w(self, Z, unit=&#39;mm&#39;):
        &#34;&#34;&#34;
        Get centerline deflection w.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
            Desired output unit. Default is mm.

        Returns
        -------
        float
            Deflection w (in specified unit) of the slab.
        &#34;&#34;&#34;
        convert = {
            &#39;m&#39;: 1e-3,   # meters
            &#39;cm&#39;: 1e-1,  # centimeters
            &#39;mm&#39;: 1,     # millimeters
            &#39;um&#39;: 1e3    # micrometers
        }
        return convert[unit]*Z[2, :]

    def dw_dx(self, Z):
        &#34;&#34;&#34;
        Get first derivative w&#39; of the centerline deflection.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            First derivative w&#39; of the deflection of the slab.
        &#34;&#34;&#34;
        return Z[3, :]

    def psi(self, Z, unit=&#39;rad&#39;):
        &#34;&#34;&#34;
        Get midplane rotation psi.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        unit : {&#39;deg&#39;, &#39;degrees&#39;, &#39;rad&#39;, &#39;radians&#39;}, optional
            Desired output unit. Default is radians.

        Returns
        -------
        psi : float
            Cross-section rotation psi (radians) of the slab.
        &#34;&#34;&#34;
        if unit in [&#39;deg&#39;, &#39;degree&#39;, &#39;degrees&#39;]:
            psi = np.rad2deg(Z[4, :])
        elif unit in [&#39;rad&#39;, &#39;radian&#39;, &#39;radians&#39;]:
            psi = Z[4, :]
        return psi

    def dpsi_dx(self, Z):
        &#34;&#34;&#34;
        Get first derivative psi&#39; of the midplane rotation.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            First derivative psi&#39; of the midplane rotation (radians/mm)
            of the slab.
        &#34;&#34;&#34;
        return Z[5, :]

    # pylint: enable=no-self-use
    def u(self, Z, z0, unit=&#39;mm&#39;):
        &#34;&#34;&#34;
        Get horizontal displacement u = u0 + z0 psi.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        z0 : float
            Z-coordinate (mm) where u is to be evaluated.
        unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
            Desired output unit. Default is mm.

        Returns
        -------
        float
            Horizontal displacement u (unit) of the slab.
        &#34;&#34;&#34;
        convert = {
            &#39;m&#39;: 1e-3,   # meters
            &#39;cm&#39;: 1e-1,  # centimeters
            &#39;mm&#39;: 1,     # millimeters
            &#39;um&#39;: 1e3    # micrometers
        }
        return convert[unit]*(Z[0, :] + z0*self.psi(Z))

    def du_dx(self, Z, z0):
        &#34;&#34;&#34;
        Get first derivative of the horizontal displacement.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        z0 : float
            Z-coordinate (mm) where u is to be evaluated.

        Returns
        -------
        float
            First derivative u&#39; = u0&#39; + z0 psi&#39; of the horizontal
            displacement of the slab.
        &#34;&#34;&#34;
        return Z[1, :] + z0*self.dpsi_dx(Z)

    def N(self, Z):
        &#34;&#34;&#34;
        Get the axial normal force N = A11 u&#39; + B11 psi&#39; in the slab.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Axial normal force N (N) in the slab.
        &#34;&#34;&#34;
        return self.A11*Z[1, :] + self.B11*Z[5, :]

    def M(self, Z):
        &#34;&#34;&#34;
        Get bending moment M = B11 u&#39; + D11 psi&#39; in the slab.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Bending moment M (Nmm) in the slab.
        &#34;&#34;&#34;
        return self.B11*Z[1, :] + self.D11*Z[5, :]

    def V(self, Z):
        &#34;&#34;&#34;
        Get vertical shear force V = kA55(w&#39; + psi).

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Vertical shear force V (N) in the slab.
        &#34;&#34;&#34;
        return self.kA55*(Z[3, :] + Z[4, :])

    def sig(self, Z, unit=&#39;MPa&#39;):
        &#34;&#34;&#34;
        Get weak-layer normal stress.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
            Desired output unit. Default is MPa.

        Returns
        -------
        float
            Weak-layer normal stress sigma (in specified unit).
        &#34;&#34;&#34;
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }
        return -convert[unit]*self.kn*self.w(Z)

    def tau(self, Z, unit=&#39;MPa&#39;):
        &#34;&#34;&#34;
        Get weak-layer shear stress.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
            Desired output unit. Default is MPa.

        Returns
        -------
        float
            Weak-layer shear stress tau (in specified unit).
        &#34;&#34;&#34;
        convert = {
            &#39;kPa&#39;: 1e3,
            &#39;MPa&#39;: 1
        }
        return -convert[unit]*self.kt*(
            self.dw_dx(Z)*self.t/2 - self.u(Z, z0=self.h/2))

    def eps(self, Z):
        &#34;&#34;&#34;
        Get weak-layer normal strain.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Weak-layer normal strain epsilon.
        &#34;&#34;&#34;
        return -self.w(Z)/self.t

    def gamma(self, Z):
        &#34;&#34;&#34;
        Get weak-layer shear strain.

        Arguments
        ---------
        Z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

        Returns
        -------
        float
            Weak-layer shear strain gamma.
        &#34;&#34;&#34;
        return self.dw_dx(Z)/2 - self.u(Z, z0=self.h/2)/self.t

    def Gi(self, Ztip, unit=&#39;kJ/m^2&#39;):
        &#34;&#34;&#34;
        Get mode I differential energy release rate at crack tip.

        Arguments
        ---------
        Ztip : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
            at the crack tip.
        unit : {&#39;N/mm&#39;, &#39;kJ/m^2&#39;, &#39;J/m^2&#39;}, optional
            Desired output unit. Default is kJ/m^2.

        Returns
        -------
        float
            Mode I differential energy release rate (N/mm = kJ/m^2
            or J/m^2) at the crack tip.
        &#34;&#34;&#34;
        convert = {
            &#39;J/m^2&#39;: 1e3,   # joule per square meter
            &#39;kJ/m^2&#39;: 1,    # kilojoule per square meter
            &#39;N/mm&#39;: 1       # newton per millimeter
        }
        return convert[unit]*self.sig(Ztip)**2/(2*self.kn)

    def Gii(self, Ztip, unit=&#39;kJ/m^2&#39;):
        &#34;&#34;&#34;
        Get mode II differential energy release rate at crack tip.

        Arguments
        ---------
        Ztip : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
            at the crack tip.
        unit : {&#39;N/mm&#39;, &#39;kJ/m^2&#39;, &#39;J/m^2&#39;}, optional
            Desired output unit. Default is kJ/m^2 = N/mm.

        Returns
        -------
        float
            Mode II differential energy release rate (N/mm = kJ/m^2
            or J/m^2) at the crack tip.
        &#34;&#34;&#34;
        convert = {
            &#39;J/m^2&#39;: 1e3,   # joule per square meter
            &#39;kJ/m^2&#39;: 1,    # kilojoule per square meter
            &#39;N/mm&#39;: 1       # newton per millimeter
        }
        return convert[unit]*self.tau(Ztip)**2/(2*self.kt)

    def int1(self, x, z0, z1):
        &#34;&#34;&#34;
        Get mode I crack opening integrand at integration points xi.

        Arguments
        ---------
        x : float, ndarray
            X-coordinate where integrand is to be evaluated (mm).
        z0 : callable
            Function that returns the solution vector of the uncracked
            configuration.
        z1 : callable
            Function that returns the solution vector of the cracked
            configuration.

        Returns
        -------
        float or ndarray
            Integrant of the mode I crack opening integral.
        &#34;&#34;&#34;
        return self.sig(z0(x))*self.eps(z1(x))*self.t

    def int2(self, x, z0, z1):
        &#34;&#34;&#34;
        Get mode II crack opening integrand at integration points xi.

        Arguments
        ---------
        x : float, ndarray
            X-coordinate where integrand is to be evaluated (mm).
        z0 : callable
            Function that returns the solution vector of the uncracked
            configuration.
        z1 : callable
            Function that returns the solution vector of the cracked
            configuration.

        Returns
        -------
        float or ndarray
            Integrant of the mode II crack opening integral.
        &#34;&#34;&#34;
        return self.tau(z0(x))*self.gamma(z1(x))*self.t

    def dz_dx(self, z, phi):
        &#34;&#34;&#34;
        Get first derivative z&#39;(x) = K*z(x) + q of the solution vector.

        z&#39;(x) = [u&#39;(x) u&#39;&#39;(x) w&#39;(x) w&#39;&#39;(x) psi&#39;(x), psi&#39;&#39;(x)]^T

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            First derivative z&#39;(x) for the solution vector (6x1).
        &#34;&#34;&#34;
        K = self.calc_system_matrix()
        q = self.get_load_vector(phi)
        return np.dot(K, z) + q

    def dz_dxdx(self, z, phi):
        &#34;&#34;&#34;
        Get second derivative z&#39;&#39;(x) = K*z&#39;(x) of the solution vector.

        z&#39;&#39;(x) = [u&#39;&#39;(x) u&#39;&#39;&#39;(x) w&#39;&#39;(x) w&#39;&#39;&#39;(x) psi&#39;&#39;(x), psi&#39;&#39;&#39;(x)]^T

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Second derivative z&#39;&#39;(x) = (K*z(x) + q)&#39; = K*z&#39;(x) = K*(K*z(x) + q)
            of the solution vector (6x1).
        &#34;&#34;&#34;
        K = self.calc_system_matrix()
        q = self.get_load_vector(phi)
        dz_dx = np.dot(K, z) + q
        return np.dot(K, dz_dx)

    def du0_dxdx(self, z, phi):
        &#34;&#34;&#34;
        Get second derivative of the horiz. centerline displacement u0&#39;&#39;(x).

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Second derivative of the horizontal centerline displacement
            u0&#39;&#39;(x) (1/mm).
        &#34;&#34;&#34;
        return self.dz_dx(z, phi)[1, :]

    def dpsi_dxdx(self, z, phi):
        &#34;&#34;&#34;
        Get second derivative of the cross-section rotation psi&#39;&#39;(x).

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Second derivative of the cross-section rotation psi&#39;&#39;(x) (1/mm^2).
        &#34;&#34;&#34;
        return self.dz_dx(z, phi)[5, :]

    def du0_dxdxdx(self, z, phi):
        &#34;&#34;&#34;
        Get third derivative of the horiz. centerline displacement u0&#39;&#39;&#39;(x).

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Third derivative of the horizontal centerline displacement
            u0&#39;&#39;&#39;(x) (1/mm^2).
        &#34;&#34;&#34;
        return self.dz_dxdx(z, phi)[1, :]

    def dpsi_dxdxdx(self, z, phi):
        &#34;&#34;&#34;
        Get third derivative of the cross-section rotation psi&#39;&#39;&#39;(x).

        Parameters
        ----------
        z : ndarray
            Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
        phi : float
            Inclination (degrees). Counterclockwise positive.

        Returns
        -------
        ndarray, float
            Third derivative of the cross-section rotation psi&#39;&#39;&#39;(x) (1/mm^3).
        &#34;&#34;&#34;
        return self.dz_dxdx(z, phi)[5, :]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weac.inverse.Inverse" href="inverse.html#weac.inverse.Inverse">Inverse</a></li>
<li><a title="weac.layered.Layered" href="layered.html#weac.layered.Layered">Layered</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="weac.mixins.FieldQuantitiesMixin.Gi"><code class="name flex">
<span>def <span class="ident">Gi</span></span>(<span>self, Ztip, unit='kJ/m^2')</span>
</code></dt>
<dd>
<div class="desc"><p>Get mode I differential energy release rate at crack tip.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Ztip</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T
at the crack tip.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'N/mm', 'kJ/m^2', 'J/m^2'}</code>, optional</dt>
<dd>Desired output unit. Default is kJ/m^2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Mode I differential energy release rate (N/mm = kJ/m^2
or J/m^2) at the crack tip.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Gi(self, Ztip, unit=&#39;kJ/m^2&#39;):
    &#34;&#34;&#34;
    Get mode I differential energy release rate at crack tip.

    Arguments
    ---------
    Ztip : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
        at the crack tip.
    unit : {&#39;N/mm&#39;, &#39;kJ/m^2&#39;, &#39;J/m^2&#39;}, optional
        Desired output unit. Default is kJ/m^2.

    Returns
    -------
    float
        Mode I differential energy release rate (N/mm = kJ/m^2
        or J/m^2) at the crack tip.
    &#34;&#34;&#34;
    convert = {
        &#39;J/m^2&#39;: 1e3,   # joule per square meter
        &#39;kJ/m^2&#39;: 1,    # kilojoule per square meter
        &#39;N/mm&#39;: 1       # newton per millimeter
    }
    return convert[unit]*self.sig(Ztip)**2/(2*self.kn)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.Gii"><code class="name flex">
<span>def <span class="ident">Gii</span></span>(<span>self, Ztip, unit='kJ/m^2')</span>
</code></dt>
<dd>
<div class="desc"><p>Get mode II differential energy release rate at crack tip.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Ztip</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T
at the crack tip.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'N/mm', 'kJ/m^2', 'J/m^2'}</code>, optional</dt>
<dd>Desired output unit. Default is kJ/m^2 = N/mm.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Mode II differential energy release rate (N/mm = kJ/m^2
or J/m^2) at the crack tip.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Gii(self, Ztip, unit=&#39;kJ/m^2&#39;):
    &#34;&#34;&#34;
    Get mode II differential energy release rate at crack tip.

    Arguments
    ---------
    Ztip : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T
        at the crack tip.
    unit : {&#39;N/mm&#39;, &#39;kJ/m^2&#39;, &#39;J/m^2&#39;}, optional
        Desired output unit. Default is kJ/m^2 = N/mm.

    Returns
    -------
    float
        Mode II differential energy release rate (N/mm = kJ/m^2
        or J/m^2) at the crack tip.
    &#34;&#34;&#34;
    convert = {
        &#39;J/m^2&#39;: 1e3,   # joule per square meter
        &#39;kJ/m^2&#39;: 1,    # kilojoule per square meter
        &#39;N/mm&#39;: 1       # newton per millimeter
    }
    return convert[unit]*self.tau(Ztip)**2/(2*self.kt)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.M"><code class="name flex">
<span>def <span class="ident">M</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get bending moment M = B11 u' + D11 psi' in the slab.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Bending moment M (Nmm) in the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def M(self, Z):
    &#34;&#34;&#34;
    Get bending moment M = B11 u&#39; + D11 psi&#39; in the slab.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    float
        Bending moment M (Nmm) in the slab.
    &#34;&#34;&#34;
    return self.B11*Z[1, :] + self.D11*Z[5, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.N"><code class="name flex">
<span>def <span class="ident">N</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the axial normal force N = A11 u' + B11 psi' in the slab.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Axial normal force N (N) in the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def N(self, Z):
    &#34;&#34;&#34;
    Get the axial normal force N = A11 u&#39; + B11 psi&#39; in the slab.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    float
        Axial normal force N (N) in the slab.
    &#34;&#34;&#34;
    return self.A11*Z[1, :] + self.B11*Z[5, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.V"><code class="name flex">
<span>def <span class="ident">V</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get vertical shear force V = kA55(w' + psi).</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Vertical shear force V (N) in the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V(self, Z):
    &#34;&#34;&#34;
    Get vertical shear force V = kA55(w&#39; + psi).

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    float
        Vertical shear force V (N) in the slab.
    &#34;&#34;&#34;
    return self.kA55*(Z[3, :] + Z[4, :])</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.dpsi_dx"><code class="name flex">
<span>def <span class="ident">dpsi_dx</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get first derivative psi' of the midplane rotation.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>First derivative psi' of the midplane rotation (radians/mm)
of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dpsi_dx(self, Z):
    &#34;&#34;&#34;
    Get first derivative psi&#39; of the midplane rotation.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    float
        First derivative psi&#39; of the midplane rotation (radians/mm)
        of the slab.
    &#34;&#34;&#34;
    return Z[5, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.dpsi_dxdx"><code class="name flex">
<span>def <span class="ident">dpsi_dxdx</span></span>(<span>self, z, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Get second derivative of the cross-section rotation psi''(x).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray, float</code></dt>
<dd>Second derivative of the cross-section rotation psi''(x) (1/mm^2).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dpsi_dxdx(self, z, phi):
    &#34;&#34;&#34;
    Get second derivative of the cross-section rotation psi&#39;&#39;(x).

    Parameters
    ----------
    z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    phi : float
        Inclination (degrees). Counterclockwise positive.

    Returns
    -------
    ndarray, float
        Second derivative of the cross-section rotation psi&#39;&#39;(x) (1/mm^2).
    &#34;&#34;&#34;
    return self.dz_dx(z, phi)[5, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.dpsi_dxdxdx"><code class="name flex">
<span>def <span class="ident">dpsi_dxdxdx</span></span>(<span>self, z, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Get third derivative of the cross-section rotation psi'''(x).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray, float</code></dt>
<dd>Third derivative of the cross-section rotation psi'''(x) (1/mm^3).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dpsi_dxdxdx(self, z, phi):
    &#34;&#34;&#34;
    Get third derivative of the cross-section rotation psi&#39;&#39;&#39;(x).

    Parameters
    ----------
    z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    phi : float
        Inclination (degrees). Counterclockwise positive.

    Returns
    -------
    ndarray, float
        Third derivative of the cross-section rotation psi&#39;&#39;&#39;(x) (1/mm^3).
    &#34;&#34;&#34;
    return self.dz_dxdx(z, phi)[5, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.du0_dxdx"><code class="name flex">
<span>def <span class="ident">du0_dxdx</span></span>(<span>self, z, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Get second derivative of the horiz. centerline displacement u0''(x).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray, float</code></dt>
<dd>Second derivative of the horizontal centerline displacement
u0''(x) (1/mm).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def du0_dxdx(self, z, phi):
    &#34;&#34;&#34;
    Get second derivative of the horiz. centerline displacement u0&#39;&#39;(x).

    Parameters
    ----------
    z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    phi : float
        Inclination (degrees). Counterclockwise positive.

    Returns
    -------
    ndarray, float
        Second derivative of the horizontal centerline displacement
        u0&#39;&#39;(x) (1/mm).
    &#34;&#34;&#34;
    return self.dz_dx(z, phi)[1, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.du0_dxdxdx"><code class="name flex">
<span>def <span class="ident">du0_dxdxdx</span></span>(<span>self, z, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Get third derivative of the horiz. centerline displacement u0'''(x).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray, float</code></dt>
<dd>Third derivative of the horizontal centerline displacement
u0'''(x) (1/mm^2).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def du0_dxdxdx(self, z, phi):
    &#34;&#34;&#34;
    Get third derivative of the horiz. centerline displacement u0&#39;&#39;&#39;(x).

    Parameters
    ----------
    z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    phi : float
        Inclination (degrees). Counterclockwise positive.

    Returns
    -------
    ndarray, float
        Third derivative of the horizontal centerline displacement
        u0&#39;&#39;&#39;(x) (1/mm^2).
    &#34;&#34;&#34;
    return self.dz_dxdx(z, phi)[1, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.du_dx"><code class="name flex">
<span>def <span class="ident">du_dx</span></span>(<span>self, Z, z0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get first derivative of the horizontal displacement.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>float</code></dt>
<dd>Z-coordinate (mm) where u is to be evaluated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>First derivative u' = u0' + z0 psi' of the horizontal
displacement of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def du_dx(self, Z, z0):
    &#34;&#34;&#34;
    Get first derivative of the horizontal displacement.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    z0 : float
        Z-coordinate (mm) where u is to be evaluated.

    Returns
    -------
    float
        First derivative u&#39; = u0&#39; + z0 psi&#39; of the horizontal
        displacement of the slab.
    &#34;&#34;&#34;
    return Z[1, :] + z0*self.dpsi_dx(Z)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.dw_dx"><code class="name flex">
<span>def <span class="ident">dw_dx</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get first derivative w' of the centerline deflection.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>First derivative w' of the deflection of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dw_dx(self, Z):
    &#34;&#34;&#34;
    Get first derivative w&#39; of the centerline deflection.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    float
        First derivative w&#39; of the deflection of the slab.
    &#34;&#34;&#34;
    return Z[3, :]</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.dz_dx"><code class="name flex">
<span>def <span class="ident">dz_dx</span></span>(<span>self, z, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Get first derivative z'(x) = K*z(x) + q of the solution vector.</p>
<p>z'(x) = [u'(x) u''(x) w'(x) w''(x) psi'(x), psi''(x)]^T</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x), psi'(x)]^T</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray, float</code></dt>
<dd>First derivative z'(x) for the solution vector (6x1).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dz_dx(self, z, phi):
    &#34;&#34;&#34;
    Get first derivative z&#39;(x) = K*z(x) + q of the solution vector.

    z&#39;(x) = [u&#39;(x) u&#39;&#39;(x) w&#39;(x) w&#39;&#39;(x) psi&#39;(x), psi&#39;&#39;(x)]^T

    Parameters
    ----------
    z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
    phi : float
        Inclination (degrees). Counterclockwise positive.

    Returns
    -------
    ndarray, float
        First derivative z&#39;(x) for the solution vector (6x1).
    &#34;&#34;&#34;
    K = self.calc_system_matrix()
    q = self.get_load_vector(phi)
    return np.dot(K, z) + q</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.dz_dxdx"><code class="name flex">
<span>def <span class="ident">dz_dxdx</span></span>(<span>self, z, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Get second derivative z''(x) = K*z'(x) of the solution vector.</p>
<p>z''(x) = [u''(x) u'''(x) w''(x) w'''(x) psi''(x), psi'''(x)]^T</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x), psi'(x)]^T</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees). Counterclockwise positive.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray, float</code></dt>
<dd>Second derivative z''(x) = (K<em>z(x) + q)' = K</em>z'(x) = K<em>(K</em>z(x) + q)
of the solution vector (6x1).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dz_dxdx(self, z, phi):
    &#34;&#34;&#34;
    Get second derivative z&#39;&#39;(x) = K*z&#39;(x) of the solution vector.

    z&#39;&#39;(x) = [u&#39;&#39;(x) u&#39;&#39;&#39;(x) w&#39;&#39;(x) w&#39;&#39;&#39;(x) psi&#39;&#39;(x), psi&#39;&#39;&#39;(x)]^T

    Parameters
    ----------
    z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x), psi&#39;(x)]^T
    phi : float
        Inclination (degrees). Counterclockwise positive.

    Returns
    -------
    ndarray, float
        Second derivative z&#39;&#39;(x) = (K*z(x) + q)&#39; = K*z&#39;(x) = K*(K*z(x) + q)
        of the solution vector (6x1).
    &#34;&#34;&#34;
    K = self.calc_system_matrix()
    q = self.get_load_vector(phi)
    dz_dx = np.dot(K, z) + q
    return np.dot(K, dz_dx)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.eps"><code class="name flex">
<span>def <span class="ident">eps</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get weak-layer normal strain.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Weak-layer normal strain epsilon.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eps(self, Z):
    &#34;&#34;&#34;
    Get weak-layer normal strain.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    float
        Weak-layer normal strain epsilon.
    &#34;&#34;&#34;
    return -self.w(Z)/self.t</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.gamma"><code class="name flex">
<span>def <span class="ident">gamma</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Get weak-layer shear strain.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Weak-layer shear strain gamma.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gamma(self, Z):
    &#34;&#34;&#34;
    Get weak-layer shear strain.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.

    Returns
    -------
    float
        Weak-layer shear strain gamma.
    &#34;&#34;&#34;
    return self.dw_dx(Z)/2 - self.u(Z, z0=self.h/2)/self.t</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.int1"><code class="name flex">
<span>def <span class="ident">int1</span></span>(<span>self, x, z0, z1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get mode I crack opening integrand at integration points xi.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float, ndarray</code></dt>
<dd>X-coordinate where integrand is to be evaluated (mm).</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function that returns the solution vector of the uncracked
configuration.</dd>
<dt><strong><code>z1</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function that returns the solution vector of the cracked
configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>ndarray</code></dt>
<dd>Integrant of the mode I crack opening integral.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int1(self, x, z0, z1):
    &#34;&#34;&#34;
    Get mode I crack opening integrand at integration points xi.

    Arguments
    ---------
    x : float, ndarray
        X-coordinate where integrand is to be evaluated (mm).
    z0 : callable
        Function that returns the solution vector of the uncracked
        configuration.
    z1 : callable
        Function that returns the solution vector of the cracked
        configuration.

    Returns
    -------
    float or ndarray
        Integrant of the mode I crack opening integral.
    &#34;&#34;&#34;
    return self.sig(z0(x))*self.eps(z1(x))*self.t</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.int2"><code class="name flex">
<span>def <span class="ident">int2</span></span>(<span>self, x, z0, z1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get mode II crack opening integrand at integration points xi.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float, ndarray</code></dt>
<dd>X-coordinate where integrand is to be evaluated (mm).</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function that returns the solution vector of the uncracked
configuration.</dd>
<dt><strong><code>z1</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function that returns the solution vector of the cracked
configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>ndarray</code></dt>
<dd>Integrant of the mode II crack opening integral.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int2(self, x, z0, z1):
    &#34;&#34;&#34;
    Get mode II crack opening integrand at integration points xi.

    Arguments
    ---------
    x : float, ndarray
        X-coordinate where integrand is to be evaluated (mm).
    z0 : callable
        Function that returns the solution vector of the uncracked
        configuration.
    z1 : callable
        Function that returns the solution vector of the cracked
        configuration.

    Returns
    -------
    float or ndarray
        Integrant of the mode II crack opening integral.
    &#34;&#34;&#34;
    return self.tau(z0(x))*self.gamma(z1(x))*self.t</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.psi"><code class="name flex">
<span>def <span class="ident">psi</span></span>(<span>self, Z, unit='rad')</span>
</code></dt>
<dd>
<div class="desc"><p>Get midplane rotation psi.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'deg', 'degrees', 'rad', 'radians'}</code>, optional</dt>
<dd>Desired output unit. Default is radians.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psi</code></strong> :&ensp;<code>float</code></dt>
<dd>Cross-section rotation psi (radians) of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def psi(self, Z, unit=&#39;rad&#39;):
    &#34;&#34;&#34;
    Get midplane rotation psi.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    unit : {&#39;deg&#39;, &#39;degrees&#39;, &#39;rad&#39;, &#39;radians&#39;}, optional
        Desired output unit. Default is radians.

    Returns
    -------
    psi : float
        Cross-section rotation psi (radians) of the slab.
    &#34;&#34;&#34;
    if unit in [&#39;deg&#39;, &#39;degree&#39;, &#39;degrees&#39;]:
        psi = np.rad2deg(Z[4, :])
    elif unit in [&#39;rad&#39;, &#39;radian&#39;, &#39;radians&#39;]:
        psi = Z[4, :]
    return psi</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.sig"><code class="name flex">
<span>def <span class="ident">sig</span></span>(<span>self, Z, unit='MPa')</span>
</code></dt>
<dd>
<div class="desc"><p>Get weak-layer normal stress.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'MPa', 'kPa'}</code>, optional</dt>
<dd>Desired output unit. Default is MPa.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Weak-layer normal stress sigma (in specified unit).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sig(self, Z, unit=&#39;MPa&#39;):
    &#34;&#34;&#34;
    Get weak-layer normal stress.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
        Desired output unit. Default is MPa.

    Returns
    -------
    float
        Weak-layer normal stress sigma (in specified unit).
    &#34;&#34;&#34;
    convert = {
        &#39;kPa&#39;: 1e3,
        &#39;MPa&#39;: 1
    }
    return -convert[unit]*self.kn*self.w(Z)</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.tau"><code class="name flex">
<span>def <span class="ident">tau</span></span>(<span>self, Z, unit='MPa')</span>
</code></dt>
<dd>
<div class="desc"><p>Get weak-layer shear stress.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'MPa', 'kPa'}</code>, optional</dt>
<dd>Desired output unit. Default is MPa.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Weak-layer shear stress tau (in specified unit).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tau(self, Z, unit=&#39;MPa&#39;):
    &#34;&#34;&#34;
    Get weak-layer shear stress.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
        Desired output unit. Default is MPa.

    Returns
    -------
    float
        Weak-layer shear stress tau (in specified unit).
    &#34;&#34;&#34;
    convert = {
        &#39;kPa&#39;: 1e3,
        &#39;MPa&#39;: 1
    }
    return -convert[unit]*self.kt*(
        self.dw_dx(Z)*self.t/2 - self.u(Z, z0=self.h/2))</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.u"><code class="name flex">
<span>def <span class="ident">u</span></span>(<span>self, Z, z0, unit='mm')</span>
</code></dt>
<dd>
<div class="desc"><p>Get horizontal displacement u = u0 + z0 psi.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>float</code></dt>
<dd>Z-coordinate (mm) where u is to be evaluated.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'m', 'cm', 'mm', 'um'}</code>, optional</dt>
<dd>Desired output unit. Default is mm.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Horizontal displacement u (unit) of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def u(self, Z, z0, unit=&#39;mm&#39;):
    &#34;&#34;&#34;
    Get horizontal displacement u = u0 + z0 psi.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    z0 : float
        Z-coordinate (mm) where u is to be evaluated.
    unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
        Desired output unit. Default is mm.

    Returns
    -------
    float
        Horizontal displacement u (unit) of the slab.
    &#34;&#34;&#34;
    convert = {
        &#39;m&#39;: 1e-3,   # meters
        &#39;cm&#39;: 1e-1,  # centimeters
        &#39;mm&#39;: 1,     # millimeters
        &#39;um&#39;: 1e3    # micrometers
    }
    return convert[unit]*(Z[0, :] + z0*self.psi(Z))</code></pre>
</details>
</dd>
<dt id="weac.mixins.FieldQuantitiesMixin.w"><code class="name flex">
<span>def <span class="ident">w</span></span>(<span>self, Z, unit='mm')</span>
</code></dt>
<dd>
<div class="desc"><p>Get centerline deflection w.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector [u(x) u'(x) w(x) w'(x) psi(x) psi'(x)]^T.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'m', 'cm', 'mm', 'um'}</code>, optional</dt>
<dd>Desired output unit. Default is mm.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Deflection w (in specified unit) of the slab.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def w(self, Z, unit=&#39;mm&#39;):
    &#34;&#34;&#34;
    Get centerline deflection w.

    Arguments
    ---------
    Z : ndarray
        Solution vector [u(x) u&#39;(x) w(x) w&#39;(x) psi(x) psi&#39;(x)]^T.
    unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
        Desired output unit. Default is mm.

    Returns
    -------
    float
        Deflection w (in specified unit) of the slab.
    &#34;&#34;&#34;
    convert = {
        &#39;m&#39;: 1e-3,   # meters
        &#39;cm&#39;: 1e-1,  # centimeters
        &#39;mm&#39;: 1,     # millimeters
        &#39;um&#39;: 1e3    # micrometers
    }
    return convert[unit]*Z[2, :]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="weac.mixins.OutputMixin"><code class="flex name class">
<span>class <span class="ident">OutputMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for outputs.</p>
<p>Provides convenience methods for the assembly of output lists
such as rasterized displacements or rasterized stresses.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutputMixin:
    &#34;&#34;&#34;
    Mixin for outputs.

    Provides convenience methods for the assembly of output lists
    such as rasterized displacements or rasterized stresses.
    &#34;&#34;&#34;

    def get_weaklayer_shearstress(self, x, z, unit=&#39;MPa&#39;, removeNaNs=False):
        &#34;&#34;&#34;
        Compute weak-layer shear stress.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of unsupported
            (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
        unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
            Stress output unit. Default is MPa.
        keepNaNs : bool
            If set, do not remove

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        sig : ndarray
            Normal stress (stress unit input).
        &#34;&#34;&#34;
        # Convert coordinates from mm to cm and stresses from MPa to unit
        x = x/10
        tau = self.tau(z, unit=unit)
        # Filter stresses in unspupported segments
        if removeNaNs:
            # Remove coordinate-stress pairs where no weak layer is present
            tau = tau[~np.isnan(x)]
            x = x[~np.isnan(x)]
        else:
            # Set stress NaN where no weak layer is present
            tau[np.isnan(x)] = np.nan

        return x, tau

    def get_weaklayer_normalstress(self, x, z, unit=&#39;MPa&#39;, removeNaNs=False):
        &#34;&#34;&#34;
        Compute weak-layer normal stress.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of unsupported
            (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
        unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
            Stress output unit. Default is MPa.
        keepNaNs : bool
            If set, do not remove

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        sig : ndarray
            Normal stress (stress unit input).
        &#34;&#34;&#34;
        # Convert coordinates from mm to cm and stresses from MPa to unit
        x = x/10
        sig = self.sig(z, unit=unit)
        # Filter stresses in unspupported segments
        if removeNaNs:
            # Remove coordinate-stress pairs where no weak layer is present
            sig = sig[~np.isnan(x)]
            x = x[~np.isnan(x)]
        else:
            # Set stress NaN where no weak layer is present
            sig[np.isnan(x)] = np.nan

        return x, sig

    def get_slab_displacement(self, x, z, loc=&#39;mid&#39;, unit=&#39;mm&#39;):
        &#34;&#34;&#34;
        Compute horizontal slab displacement.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of
            unsupported (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
        loc : {&#39;top&#39;, &#39;mid&#39;, &#39;bot&#39;}
            Get displacements of top, midplane or bottom of slab.
            Default is mid.
        unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
            Displacement output unit. Default is mm.

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        ndarray
            Horizontal displacements (unit input).
        &#34;&#34;&#34;
        # Coordinates (cm)
        x = x/10
        # Locator
        z0 = {&#39;top&#39;: -self.h/2, &#39;mid&#39;: 0, &#39;bot&#39;: self.h/2}
        # Displacement (unit)
        u = self.u(z, z0=z0[loc], unit=unit)
        # Output array
        return x, u

    def get_slab_deflection(self, x, z, unit=&#39;mm&#39;):
        &#34;&#34;&#34;
        Compute vertical slab displacement.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of
            unsupported (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
            Default is mid.
        unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
            Displacement output unit. Default is mm.

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        ndarray
            Vertical deflections (unit input).
        &#34;&#34;&#34;
        # Coordinates (cm)
        x = x/10
        # Deflection (unit)
        w = self.w(z, unit=unit)
        # Output array
        return x, w

    def get_slab_rotation(self, x, z, unit=&#39;degrees&#39;):
        &#34;&#34;&#34;
        Compute slab cross-section rotation angle.

        Arguments
        ---------
        x : ndarray
            Discretized x-coordinates (mm) where coordinates of
            unsupported (no foundation) segments are NaNs.
        z : ndarray
            Solution vectors at positions x as columns of matrix z.
            Default is mid.
        unit : {&#39;deg&#39;, degrees&#39;, &#39;rad&#39;, &#39;radians&#39;}, optional
            Rotation angle output unit. Default is degrees.

        Returns
        -------
        x : ndarray
            Horizontal coordinates (cm).
        ndarray
            Cross section rotations (unit input).
        &#34;&#34;&#34;
        # Coordinates (cm)
        x = x/10
        # Cross-section rotation angle (unit)
        psi = self.psi(z, unit=unit)
        # Output array
        return x, psi</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weac.inverse.Inverse" href="inverse.html#weac.inverse.Inverse">Inverse</a></li>
<li><a title="weac.layered.Layered" href="layered.html#weac.layered.Layered">Layered</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="weac.mixins.OutputMixin.get_slab_deflection"><code class="name flex">
<span>def <span class="ident">get_slab_deflection</span></span>(<span>self, x, z, unit='mm')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute vertical slab displacement.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Discretized x-coordinates (mm) where coordinates of
unsupported (no foundation) segments are NaNs.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vectors at positions x as columns of matrix z.
Default is mid.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'m', 'cm', 'mm', 'um'}</code>, optional</dt>
<dd>Displacement output unit. Default is mm.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Horizontal coordinates (cm).</dd>
<dt><code>ndarray</code></dt>
<dd>Vertical deflections (unit input).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slab_deflection(self, x, z, unit=&#39;mm&#39;):
    &#34;&#34;&#34;
    Compute vertical slab displacement.

    Arguments
    ---------
    x : ndarray
        Discretized x-coordinates (mm) where coordinates of
        unsupported (no foundation) segments are NaNs.
    z : ndarray
        Solution vectors at positions x as columns of matrix z.
        Default is mid.
    unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
        Displacement output unit. Default is mm.

    Returns
    -------
    x : ndarray
        Horizontal coordinates (cm).
    ndarray
        Vertical deflections (unit input).
    &#34;&#34;&#34;
    # Coordinates (cm)
    x = x/10
    # Deflection (unit)
    w = self.w(z, unit=unit)
    # Output array
    return x, w</code></pre>
</details>
</dd>
<dt id="weac.mixins.OutputMixin.get_slab_displacement"><code class="name flex">
<span>def <span class="ident">get_slab_displacement</span></span>(<span>self, x, z, loc='mid', unit='mm')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute horizontal slab displacement.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Discretized x-coordinates (mm) where coordinates of
unsupported (no foundation) segments are NaNs.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vectors at positions x as columns of matrix z.</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>{'top', 'mid', 'bot'}</code></dt>
<dd>Get displacements of top, midplane or bottom of slab.
Default is mid.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'m', 'cm', 'mm', 'um'}</code>, optional</dt>
<dd>Displacement output unit. Default is mm.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Horizontal coordinates (cm).</dd>
<dt><code>ndarray</code></dt>
<dd>Horizontal displacements (unit input).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slab_displacement(self, x, z, loc=&#39;mid&#39;, unit=&#39;mm&#39;):
    &#34;&#34;&#34;
    Compute horizontal slab displacement.

    Arguments
    ---------
    x : ndarray
        Discretized x-coordinates (mm) where coordinates of
        unsupported (no foundation) segments are NaNs.
    z : ndarray
        Solution vectors at positions x as columns of matrix z.
    loc : {&#39;top&#39;, &#39;mid&#39;, &#39;bot&#39;}
        Get displacements of top, midplane or bottom of slab.
        Default is mid.
    unit : {&#39;m&#39;, &#39;cm&#39;, &#39;mm&#39;, &#39;um&#39;}, optional
        Displacement output unit. Default is mm.

    Returns
    -------
    x : ndarray
        Horizontal coordinates (cm).
    ndarray
        Horizontal displacements (unit input).
    &#34;&#34;&#34;
    # Coordinates (cm)
    x = x/10
    # Locator
    z0 = {&#39;top&#39;: -self.h/2, &#39;mid&#39;: 0, &#39;bot&#39;: self.h/2}
    # Displacement (unit)
    u = self.u(z, z0=z0[loc], unit=unit)
    # Output array
    return x, u</code></pre>
</details>
</dd>
<dt id="weac.mixins.OutputMixin.get_slab_rotation"><code class="name flex">
<span>def <span class="ident">get_slab_rotation</span></span>(<span>self, x, z, unit='degrees')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute slab cross-section rotation angle.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Discretized x-coordinates (mm) where coordinates of
unsupported (no foundation) segments are NaNs.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vectors at positions x as columns of matrix z.
Default is mid.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'deg', degrees', 'rad', 'radians'}</code>, optional</dt>
<dd>Rotation angle output unit. Default is degrees.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Horizontal coordinates (cm).</dd>
<dt><code>ndarray</code></dt>
<dd>Cross section rotations (unit input).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slab_rotation(self, x, z, unit=&#39;degrees&#39;):
    &#34;&#34;&#34;
    Compute slab cross-section rotation angle.

    Arguments
    ---------
    x : ndarray
        Discretized x-coordinates (mm) where coordinates of
        unsupported (no foundation) segments are NaNs.
    z : ndarray
        Solution vectors at positions x as columns of matrix z.
        Default is mid.
    unit : {&#39;deg&#39;, degrees&#39;, &#39;rad&#39;, &#39;radians&#39;}, optional
        Rotation angle output unit. Default is degrees.

    Returns
    -------
    x : ndarray
        Horizontal coordinates (cm).
    ndarray
        Cross section rotations (unit input).
    &#34;&#34;&#34;
    # Coordinates (cm)
    x = x/10
    # Cross-section rotation angle (unit)
    psi = self.psi(z, unit=unit)
    # Output array
    return x, psi</code></pre>
</details>
</dd>
<dt id="weac.mixins.OutputMixin.get_weaklayer_normalstress"><code class="name flex">
<span>def <span class="ident">get_weaklayer_normalstress</span></span>(<span>self, x, z, unit='MPa', removeNaNs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute weak-layer normal stress.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Discretized x-coordinates (mm) where coordinates of unsupported
(no foundation) segments are NaNs.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vectors at positions x as columns of matrix z.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'MPa', 'kPa'}</code>, optional</dt>
<dd>Stress output unit. Default is MPa.</dd>
<dt><strong><code>keepNaNs</code></strong> :&ensp;<code>bool</code></dt>
<dd>If set, do not remove</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Horizontal coordinates (cm).</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Normal stress (stress unit input).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weaklayer_normalstress(self, x, z, unit=&#39;MPa&#39;, removeNaNs=False):
    &#34;&#34;&#34;
    Compute weak-layer normal stress.

    Arguments
    ---------
    x : ndarray
        Discretized x-coordinates (mm) where coordinates of unsupported
        (no foundation) segments are NaNs.
    z : ndarray
        Solution vectors at positions x as columns of matrix z.
    unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
        Stress output unit. Default is MPa.
    keepNaNs : bool
        If set, do not remove

    Returns
    -------
    x : ndarray
        Horizontal coordinates (cm).
    sig : ndarray
        Normal stress (stress unit input).
    &#34;&#34;&#34;
    # Convert coordinates from mm to cm and stresses from MPa to unit
    x = x/10
    sig = self.sig(z, unit=unit)
    # Filter stresses in unspupported segments
    if removeNaNs:
        # Remove coordinate-stress pairs where no weak layer is present
        sig = sig[~np.isnan(x)]
        x = x[~np.isnan(x)]
    else:
        # Set stress NaN where no weak layer is present
        sig[np.isnan(x)] = np.nan

    return x, sig</code></pre>
</details>
</dd>
<dt id="weac.mixins.OutputMixin.get_weaklayer_shearstress"><code class="name flex">
<span>def <span class="ident">get_weaklayer_shearstress</span></span>(<span>self, x, z, unit='MPa', removeNaNs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute weak-layer shear stress.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Discretized x-coordinates (mm) where coordinates of unsupported
(no foundation) segments are NaNs.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vectors at positions x as columns of matrix z.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'MPa', 'kPa'}</code>, optional</dt>
<dd>Stress output unit. Default is MPa.</dd>
<dt><strong><code>keepNaNs</code></strong> :&ensp;<code>bool</code></dt>
<dd>If set, do not remove</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Horizontal coordinates (cm).</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Normal stress (stress unit input).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weaklayer_shearstress(self, x, z, unit=&#39;MPa&#39;, removeNaNs=False):
    &#34;&#34;&#34;
    Compute weak-layer shear stress.

    Arguments
    ---------
    x : ndarray
        Discretized x-coordinates (mm) where coordinates of unsupported
        (no foundation) segments are NaNs.
    z : ndarray
        Solution vectors at positions x as columns of matrix z.
    unit : {&#39;MPa&#39;, &#39;kPa&#39;}, optional
        Stress output unit. Default is MPa.
    keepNaNs : bool
        If set, do not remove

    Returns
    -------
    x : ndarray
        Horizontal coordinates (cm).
    sig : ndarray
        Normal stress (stress unit input).
    &#34;&#34;&#34;
    # Convert coordinates from mm to cm and stresses from MPa to unit
    x = x/10
    tau = self.tau(z, unit=unit)
    # Filter stresses in unspupported segments
    if removeNaNs:
        # Remove coordinate-stress pairs where no weak layer is present
        tau = tau[~np.isnan(x)]
        x = x[~np.isnan(x)]
    else:
        # Set stress NaN where no weak layer is present
        tau[np.isnan(x)] = np.nan

    return x, tau</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="weac.mixins.SolutionMixin"><code class="flex name class">
<span>class <span class="ident">SolutionMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for the solution of boundary value problems.</p>
<p>Provides methods for the assembly of the system of equations
and for the computation of the free constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SolutionMixin:
    &#34;&#34;&#34;
    Mixin for the solution of boundary value problems.

    Provides methods for the assembly of the system of equations
    and for the computation of the free constants.
    &#34;&#34;&#34;

    def mode_td(self, l=0):
        &#34;&#34;&#34;
        Identify the mode of the pst-boundary.

        Arguments
        ---------
        l : float, optional
            Length of the segment in consideration. Default is zero.

        Returns
        -------
        mode : string
            Contains the mode for the boundary of the segment:
            A - free end, B - intermediate touchdown,
            C - full touchdown (maximum clamped end).
        &#34;&#34;&#34;
        # Classify boundary type by element length
        if l &lt;= self.lC:
            mode = &#39;A&#39;
        elif self.lC &lt; l &lt;= self.lS:
            mode = &#39;B&#39;
        elif self.lS &lt; l:
            mode = &#39;C&#39;

        return mode

    def reduce_stiffness(self, l=0, mode=&#39;A&#39;):
        &#34;&#34;&#34;
        Determines the reduction factor for a rotational spring.

        Arguments
        ---------
        l : float, optional
            Length of the segment in consideration. Default is zero.
        mode : string, optional
            Contains the mode for the boundary of the segment:
            A - free end, B - intermediate touchdown, C - full touchdown.
            Default is A.

        Returns
        -------
        kf : float
            Reduction factor.
        &#34;&#34;&#34;
        # Reduction to zero for free end bc
        if mode in [&#39;A&#39;]:
            kf = 0
        # Reduction factor for touchdown
        if mode in [&#39;B&#39;, &#39;C&#39;]:
            l = l - self.lC
            # Beta needs to take into account different weak-layer spring stiffness
            beta = self.beta*self.ratio**(1/4)
            kf=(np.cos(2*beta*l)+np.cosh(2*beta*l)-2)/(np.sin(2*beta*l)+np.sinh(2*beta*l))

        return kf

    def bc(self, z, l=0, k=False, pos=&#39;mid&#39;):
        &#34;&#34;&#34;
        Provide equations for free (pst) or infinite (skiers) ends.

        Arguments
        ---------
        z : ndarray
            Solution vector (6x1) at a certain position x.
        l : float, optional
            Length of the segment in consideration. Default is zero.
        k : boolean
            Indicates whether segment has foundation(True) or not (False).
            Default is False.
        pos : {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
            Determines whether the segement under consideration
            is a left boundary segement (left, l), one of the
            center segement (mid, m), or a right boundary
            segement (right, r). Default is &#39;mid&#39;.

        Returns
        -------
        bc : ndarray
            Boundary condition vector (lenght 3) at position x.
        &#34;&#34;&#34;
        # Check mode for free end
        mode = self.mode_td(l=l)
        # Get spring stiffness reduction factor
        kf = self.reduce_stiffness(l=l, mode=mode)
        # Get spring stiffness for collapsed weak-layer
        kR = self.calc_rot_spring(collapse=True)

        # Set boundary conditions for PST-systems
        if self.system in [&#39;pst-&#39;, &#39;-pst&#39;]:
            if not k:
                if mode in [&#39;A&#39;]:
                    # Free end
                    bc = np.array([self.N(z),
                                   self.M(z),
                                   self.V(z)
                                   ])
                elif mode in [&#39;B&#39;, &#39;C&#39;] and pos in [&#39;r&#39;, &#39;right&#39;]:
                    # Touchdown right
                    bc = np.array([self.N(z),
                                   self.M(z) + kf*kR*self.psi(z),
                                   self.w(z)
                                   ])
                elif mode in [&#39;B&#39;, &#39;C&#39;] and pos in [&#39;l&#39;, &#39;left&#39;]:
                    # Touchdown left
                    bc = np.array([self.N(z),
                                   self.M(z) - kf*kR*self.psi(z),
                                   self.w(z)
                                   ])
            else:
                # Free end
                bc = np.array([self.N(z),
                                self.M(z),
                                self.V(z)
                                ])
        # Set boundary conditions for SKIER-systems
        elif self.system in [&#39;skier&#39;, &#39;skiers&#39;]:
            # Infinite end (vanishing complementary solution)
            bc = np.array([self.u(z, z0=0),
                           self.w(z),
                           self.psi(z)
                           ])
        else:
            raise ValueError(
                &#39;Boundary conditions not defined for&#39;
                f&#39;system of type {self.system}.&#39;)

        return bc

    def eqs(self, zl, zr, l=0, k=False, pos=&#39;mid&#39;):
        &#34;&#34;&#34;
        Provide boundary or transmission conditions for beam segments.

        Arguments
        ---------
        zl : ndarray
            Solution vector (6x1) at left end of beam segement.
        zr : ndarray
            Solution vector (6x1) at right end of beam segement.
        l : float, optional
            Length of the segment in consideration. Default is zero.
        k : boolean
            Indicates whether segment has foundation(True) or not (False).
            Default is False.
        pos: {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
            Determines whether the segement under consideration
            is a left boundary segement (left, l), one of the
            center segement (mid, m), or a right boundary
            segement (right, r). Default is &#39;mid&#39;.

        Returns
        -------
        eqs : ndarray
            Vector (of length 9) of boundary conditions (3) and
            transmission conditions (6) for boundary segements
            or vector of transmission conditions (of length 6+6)
            for center segments.
        &#34;&#34;&#34;
        if pos in (&#39;l&#39;, &#39;left&#39;):
            eqs = np.array([
                self.bc(zl, l, k, pos)[0],             # Left boundary condition
                self.bc(zl, l, k, pos)[1],             # Left boundary condition
                self.bc(zl, l, k, pos)[2],             # Left boundary condition
                self.u(zr, z0=0),           # ui(xi = li)
                self.w(zr),                 # wi(xi = li)
                self.psi(zr),               # psii(xi = li)
                self.N(zr),                 # Ni(xi = li)
                self.M(zr),                 # Mi(xi = li)
                self.V(zr)])                # Vi(xi = li)
        elif pos in (&#39;m&#39;, &#39;mid&#39;):
            eqs = np.array([
                -self.u(zl, z0=0),          # -ui(xi = 0)
                -self.w(zl),                # -wi(xi = 0)
                -self.psi(zl),              # -psii(xi = 0)
                -self.N(zl),                # -Ni(xi = 0)
                -self.M(zl),                # -Mi(xi = 0)
                -self.V(zl),                # -Vi(xi = 0)
                self.u(zr, z0=0),           # ui(xi = li)
                self.w(zr),                 # wi(xi = li)
                self.psi(zr),               # psii(xi = li)
                self.N(zr),                 # Ni(xi = li)
                self.M(zr),                 # Mi(xi = li)
                self.V(zr)])                # Vi(xi = li)
        elif pos in (&#39;r&#39;, &#39;right&#39;):
            eqs = np.array([
                -self.u(zl, z0=0),          # -ui(xi = 0)
                -self.w(zl),                # -wi(xi = 0)
                -self.psi(zl),              # -psii(xi = 0)
                -self.N(zl),                # -Ni(xi = 0)
                -self.M(zl),                # -Mi(xi = 0)
                -self.V(zl),                # -Vi(xi = 0)
                self.bc(zr, l, k, pos)[0],             # Right boundary condition
                self.bc(zr, l, k, pos)[1],             # Right boundary condition
                self.bc(zr, l, k, pos)[2]])            # Right boundary condition
        else:
            raise ValueError(
                (f&#39;Invalid position argument {pos} given. &#39;
                 &#39;Valid segment positions are l, m, and r, &#39;
                 &#39;or left, mid and right.&#39;))
        return eqs

    def calc_segments(self, tdi=False, li=False, mi=False, ki=False, k0=False,
                      L=1e4, a=0, m=0, **kwargs):
        &#34;&#34;&#34;
        Assemble lists defining the segments.

        This includes length (li), foundation (ki, k0), and skier
        weight (mi).

        Arguments
        ---------
        li : squence, optional
            List of lengths of segements(mm). Used for system &#39;skiers&#39;.
        mi : squence, optional
            List of skier weigths (kg) at segement boundaries. Used for
            system &#39;skiers&#39;.
        ki : squence, optional
            List of one bool per segement indicating whether segement
            has foundation (True) or not (False) in the cracked state.
            Used for system &#39;skiers&#39;.
        k0 : squence, optional
            List of one bool per segement indicating whether segement
            has foundation(True) or not (False) in the uncracked state.
            Used for system &#39;skiers&#39;.
        L : float, optional
            Total length of model (mm). Used for systems &#39;pst-&#39;, &#39;-pst&#39;,
            and &#39;skier&#39;.
        a : float, optional
            Crack length (mm).  Used for systems &#39;pst-&#39;, &#39;-pst&#39;, and
            &#39;skier&#39;.
        phi : float, optional
            Inclination (degree).
        m : float, optional
            Weight of skier (kg) in the axial center of the model.
            Used for system &#39;skier&#39;.

        Returns
        -------
        segments : dict
            Dictionary with lists of touchdown booleans (tdi), segement
            lengths (li), skier weights (mi), and foundation booleans
            in the cracked (ki) and uncracked (k0) configurations.
        &#34;&#34;&#34;

        _ = kwargs                                      # Unused arguments
        # Set unbedded segment length
        mode = self.mode_td(l=a)
        if mode in [&#39;A&#39;, &#39;B&#39;]:
            lU = a
        if mode in [&#39;C&#39;]:
            lU = self.lS

        # Assemble list defining the segments
        if self.system == &#39;skiers&#39;:
            li = np.array(li)                           # Segment lengths
            mi = np.array(mi)                           # Skier weights
            ki = np.array(ki)                           # Crack
            k0 = np.array(k0)                           # No crack
        elif self.system == &#39;pst-&#39;:
            li = np.array([L - a, lU])                   # Segment lengths
            mi = np.array([0])                          # Skier weights
            ki = np.array([True, False])                # Crack
            k0 = np.array([True, True])                 # No crack
        elif self.system == &#39;-pst&#39;:
            li = np.array([lU, L - a])                   # Segment lengths
            mi = np.array([0])                          # Skier weights
            ki = np.array([False, True])                # Crack
            k0 = np.array([True, True])                 # No crack
        elif self.system == &#39;skier&#39;:
            lb = (L - a)/2                              # Half supported length
            lf = a/2                                    # Half free length
            li = np.array([lb, lf, lf, lb])             # Segment lengths
            mi = np.array([0, m, 0])                    # Skier weights
            ki = np.array([True, False, False, True])   # Crack
            k0 = np.array([True, True, True, True])     # No crack
        else:
            raise ValueError(f&#39;System {self.system} is not implemented.&#39;)

        # Fill dictionary
        segments = {
            &#39;nocrack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: k0},
            &#39;crack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki},
            &#39;both&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki, &#39;k0&#39;: k0}}
        return segments

    def assemble_and_solve(self, phi, li, mi, ki):
        &#34;&#34;&#34;
        Compute free constants for arbitrary beam assembly.

        Assemble LHS from supported and unsupported segments in the form
        [  ]   [ zh1  0   0  ...  0   0   0  ][   ]   [    ]   [     ]  left
        [  ]   [ zh1 zh2  0  ...  0   0   0  ][   ]   [    ]   [     ]  mid
        [  ]   [  0  zh2 zh3 ...  0   0   0  ][   ]   [    ]   [     ]  mid
        [z0] = [ ... ... ... ... ... ... ... ][ C ] + [ zp ] = [ rhs ]  mid
        [  ]   [  0   0   0  ... zhL zhM  0  ][   ]   [    ]   [     ]  mid
        [  ]   [  0   0   0  ...  0  zhM zhN ][   ]   [    ]   [     ]  mid
        [  ]   [  0   0   0  ...  0   0  zhN ][   ]   [    ]   [     ]  right
        and solve for constants C.

        Arguments
        ---------
        phi : float
            Inclination (degrees).
        li : ndarray
            List of lengths of segements (mm).
        mi : ndarray
            List of skier weigths (kg) at segement boundaries.
        ki : ndarray
            List of one bool per segement indicating whether segement
            has foundation (True) or not (False).

        Returns
        -------
        C : ndarray
            Matrix(6xN) of solution constants for a system of N
            segements. Columns contain the 6 constants of each segement.
        &#34;&#34;&#34;
        # --- CATCH ERRORS ----------------------------------------------------

        # No foundation
        if not any(ki):
            raise ValueError(&#39;Provide at least one supported segment.&#39;)
        # Mismatch of number of segements and transisions
        if len(li) != len(ki) or len(li) - 1 != len(mi):
            raise ValueError(&#39;Make sure len(li)=N, len(ki)=N, and &#39;
                             &#39;len(mi)=N-1 for a system of N segments.&#39;)

        if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
            # Boundary segments must be on foundation for infinite BCs
            if not all([ki[0], ki[-1]]):
                raise ValueError(&#39;Provide supported boundary segments in &#39;
                                 &#39;order to account for infinite extensions.&#39;)
            # Make sure infinity boundary conditions are far enough from skiers
            if li[0] &lt; 5e3 or li[-1] &lt; 5e3:
                print((&#39;WARNING: Boundary segments are short. Make sure &#39;
                       &#39;the complementary solution has decayed to the &#39;
                       &#39;boundaries.&#39;))

        # --- PREPROCESSING ---------------------------------------------------

        # Determine size of linear system of equations
        nS = len(li)            # Number of beam segments
        nDOF = 6                # Number of free constants per segment

        # Add dummy segment if only one segment provided
        if nS == 1:
            li.append(0)
            ki.append(True)
            mi.append(0)
            nS = 2

        # Assemble position vector
        pi = np.full(nS, &#39;m&#39;)
        pi[0], pi[-1] = &#39;l&#39;, &#39;r&#39;

        # Initialize matrices
        zh0 = np.zeros([nS*6, nS*nDOF])
        zp0 = np.zeros([nS*6, 1])
        rhs = np.zeros([nS*6, 1])

        # --- ASSEMBLE LINEAR SYSTEM OF EQUATIONS -----------------------------

        # Loop through segments to assemble left-hand side
        for i in range(nS):
            # Length, foundation and position of segment i
            l, k, pos = li[i], ki[i], pi[i]
            # Transmission conditions at left and right segment ends
            zhi = self.eqs(
                zl=self.zh(x=0, l=l, bed=k),
                zr=self.zh(x=l, l=l, bed=k),
                l=l, k=k, pos=pos)
            zpi = self.eqs(
                zl=self.zp(x=0, phi=phi, bed=k),
                zr=self.zp(x=l, phi=phi, bed=k),
                l=l, k=k, pos=pos)
            # Rows for left-hand side assembly
            start = 0 if i == 0 else 3
            stop = 6 if i == nS - 1 else 9
            # Assemble left-hand side
            zh0[(6*i - start):(6*i + stop), i*nDOF:(i + 1)*nDOF] = zhi
            zp0[(6*i - start):(6*i + stop)] += zpi

        # Loop through loads to assemble right-hand side
        for i, m in enumerate(mi, start=1):
            # Get skier loads
            Fn, Ft = self.get_skier_load(m, phi)
            # Right-hand side for transmission from segment i-1 to segment i
            rhs[6*i:6*i + 3] = np.vstack([Ft, -Ft*self.h/2, Fn])
        # Set rhs so that complementary integral vanishes at boundaries
        if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
            rhs[:3] = self.bc(self.zp(x=0, phi=phi, bed=ki[0]))
            rhs[-3:] = self.bc(self.zp(x=li[-1], phi=phi, bed=ki[-1]))

        # Loop through segments to set touchdown at rhs
        for i in range(nS):
            # Length, foundation and position of segment i
            l, k, pos = li[i], ki[i], pi[i]
            mode = self.mode_td(l=l)
            if not k and bool(mode in [&#39;B&#39;, &#39;C&#39;]):
                if i==0:
                    rhs[:3] = np.vstack([0,0,self.tc])
                if i == (nS - 1):
                    rhs[-3:] = np.vstack([0,0,self.tc])

        # --- SOLVE -----------------------------------------------------------

        # Solve z0 = zh0*C + zp0 = rhs for constants, i.e. zh0*C = rhs - zp0
        C = np.linalg.solve(zh0, rhs - zp0)
        # Sort (nDOF = 6) constants for each segment into columns of a matrix
        return C.reshape([-1, nDOF]).T</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="weac.inverse.Inverse" href="inverse.html#weac.inverse.Inverse">Inverse</a></li>
<li><a title="weac.layered.Layered" href="layered.html#weac.layered.Layered">Layered</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="weac.mixins.SolutionMixin.assemble_and_solve"><code class="name flex">
<span>def <span class="ident">assemble_and_solve</span></span>(<span>self, phi, li, mi, ki)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute free constants for arbitrary beam assembly.</p>
<p>Assemble LHS from supported and unsupported segments in the form
[
]
[ zh1
0
0
&hellip;
0
0
0
][
]
[
]
[
]
left
[
]
[ zh1 zh2
0
&hellip;
0
0
0
][
]
[
]
[
]
mid
[
]
[
0
zh2 zh3 &hellip;
0
0
0
][
]
[
]
[
]
mid
[z0] = [ &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; &hellip; ][ C ] + [ zp ] = [ rhs ]
mid
[
]
[
0
0
0
&hellip; zhL zhM
0
][
]
[
]
[
]
mid
[
]
[
0
0
0
&hellip;
0
zhM zhN ][
]
[
]
[
]
mid
[
]
[
0
0
0
&hellip;
0
0
zhN ][
]
[
]
[
]
right
and solve for constants C.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination (degrees).</dd>
<dt><strong><code>li</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of lengths of segements (mm).</dd>
<dt><strong><code>mi</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of skier weigths (kg) at segement boundaries.</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>List of one bool per segement indicating whether segement
has foundation (True) or not (False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix(6xN) of solution constants for a system of N
segements. Columns contain the 6 constants of each segement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assemble_and_solve(self, phi, li, mi, ki):
    &#34;&#34;&#34;
    Compute free constants for arbitrary beam assembly.

    Assemble LHS from supported and unsupported segments in the form
    [  ]   [ zh1  0   0  ...  0   0   0  ][   ]   [    ]   [     ]  left
    [  ]   [ zh1 zh2  0  ...  0   0   0  ][   ]   [    ]   [     ]  mid
    [  ]   [  0  zh2 zh3 ...  0   0   0  ][   ]   [    ]   [     ]  mid
    [z0] = [ ... ... ... ... ... ... ... ][ C ] + [ zp ] = [ rhs ]  mid
    [  ]   [  0   0   0  ... zhL zhM  0  ][   ]   [    ]   [     ]  mid
    [  ]   [  0   0   0  ...  0  zhM zhN ][   ]   [    ]   [     ]  mid
    [  ]   [  0   0   0  ...  0   0  zhN ][   ]   [    ]   [     ]  right
    and solve for constants C.

    Arguments
    ---------
    phi : float
        Inclination (degrees).
    li : ndarray
        List of lengths of segements (mm).
    mi : ndarray
        List of skier weigths (kg) at segement boundaries.
    ki : ndarray
        List of one bool per segement indicating whether segement
        has foundation (True) or not (False).

    Returns
    -------
    C : ndarray
        Matrix(6xN) of solution constants for a system of N
        segements. Columns contain the 6 constants of each segement.
    &#34;&#34;&#34;
    # --- CATCH ERRORS ----------------------------------------------------

    # No foundation
    if not any(ki):
        raise ValueError(&#39;Provide at least one supported segment.&#39;)
    # Mismatch of number of segements and transisions
    if len(li) != len(ki) or len(li) - 1 != len(mi):
        raise ValueError(&#39;Make sure len(li)=N, len(ki)=N, and &#39;
                         &#39;len(mi)=N-1 for a system of N segments.&#39;)

    if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
        # Boundary segments must be on foundation for infinite BCs
        if not all([ki[0], ki[-1]]):
            raise ValueError(&#39;Provide supported boundary segments in &#39;
                             &#39;order to account for infinite extensions.&#39;)
        # Make sure infinity boundary conditions are far enough from skiers
        if li[0] &lt; 5e3 or li[-1] &lt; 5e3:
            print((&#39;WARNING: Boundary segments are short. Make sure &#39;
                   &#39;the complementary solution has decayed to the &#39;
                   &#39;boundaries.&#39;))

    # --- PREPROCESSING ---------------------------------------------------

    # Determine size of linear system of equations
    nS = len(li)            # Number of beam segments
    nDOF = 6                # Number of free constants per segment

    # Add dummy segment if only one segment provided
    if nS == 1:
        li.append(0)
        ki.append(True)
        mi.append(0)
        nS = 2

    # Assemble position vector
    pi = np.full(nS, &#39;m&#39;)
    pi[0], pi[-1] = &#39;l&#39;, &#39;r&#39;

    # Initialize matrices
    zh0 = np.zeros([nS*6, nS*nDOF])
    zp0 = np.zeros([nS*6, 1])
    rhs = np.zeros([nS*6, 1])

    # --- ASSEMBLE LINEAR SYSTEM OF EQUATIONS -----------------------------

    # Loop through segments to assemble left-hand side
    for i in range(nS):
        # Length, foundation and position of segment i
        l, k, pos = li[i], ki[i], pi[i]
        # Transmission conditions at left and right segment ends
        zhi = self.eqs(
            zl=self.zh(x=0, l=l, bed=k),
            zr=self.zh(x=l, l=l, bed=k),
            l=l, k=k, pos=pos)
        zpi = self.eqs(
            zl=self.zp(x=0, phi=phi, bed=k),
            zr=self.zp(x=l, phi=phi, bed=k),
            l=l, k=k, pos=pos)
        # Rows for left-hand side assembly
        start = 0 if i == 0 else 3
        stop = 6 if i == nS - 1 else 9
        # Assemble left-hand side
        zh0[(6*i - start):(6*i + stop), i*nDOF:(i + 1)*nDOF] = zhi
        zp0[(6*i - start):(6*i + stop)] += zpi

    # Loop through loads to assemble right-hand side
    for i, m in enumerate(mi, start=1):
        # Get skier loads
        Fn, Ft = self.get_skier_load(m, phi)
        # Right-hand side for transmission from segment i-1 to segment i
        rhs[6*i:6*i + 3] = np.vstack([Ft, -Ft*self.h/2, Fn])
    # Set rhs so that complementary integral vanishes at boundaries
    if self.system not in [&#39;pst-&#39;, &#39;-pst&#39;]:
        rhs[:3] = self.bc(self.zp(x=0, phi=phi, bed=ki[0]))
        rhs[-3:] = self.bc(self.zp(x=li[-1], phi=phi, bed=ki[-1]))

    # Loop through segments to set touchdown at rhs
    for i in range(nS):
        # Length, foundation and position of segment i
        l, k, pos = li[i], ki[i], pi[i]
        mode = self.mode_td(l=l)
        if not k and bool(mode in [&#39;B&#39;, &#39;C&#39;]):
            if i==0:
                rhs[:3] = np.vstack([0,0,self.tc])
            if i == (nS - 1):
                rhs[-3:] = np.vstack([0,0,self.tc])

    # --- SOLVE -----------------------------------------------------------

    # Solve z0 = zh0*C + zp0 = rhs for constants, i.e. zh0*C = rhs - zp0
    C = np.linalg.solve(zh0, rhs - zp0)
    # Sort (nDOF = 6) constants for each segment into columns of a matrix
    return C.reshape([-1, nDOF]).T</code></pre>
</details>
</dd>
<dt id="weac.mixins.SolutionMixin.bc"><code class="name flex">
<span>def <span class="ident">bc</span></span>(<span>self, z, l=0, k=False, pos='mid')</span>
</code></dt>
<dd>
<div class="desc"><p>Provide equations for free (pst) or infinite (skiers) ends.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector (6x1) at a certain position x.</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the segment in consideration. Default is zero.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Indicates whether segment has foundation(True) or not (False).
Default is False.</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>{'left', 'mid', 'right', 'l', 'm', 'r'}</code>, optional</dt>
<dd>Determines whether the segement under consideration
is a left boundary segement (left, l), one of the
center segement (mid, m), or a right boundary
segement (right, r). Default is 'mid'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bc</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Boundary condition vector (lenght 3) at position x.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bc(self, z, l=0, k=False, pos=&#39;mid&#39;):
    &#34;&#34;&#34;
    Provide equations for free (pst) or infinite (skiers) ends.

    Arguments
    ---------
    z : ndarray
        Solution vector (6x1) at a certain position x.
    l : float, optional
        Length of the segment in consideration. Default is zero.
    k : boolean
        Indicates whether segment has foundation(True) or not (False).
        Default is False.
    pos : {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
        Determines whether the segement under consideration
        is a left boundary segement (left, l), one of the
        center segement (mid, m), or a right boundary
        segement (right, r). Default is &#39;mid&#39;.

    Returns
    -------
    bc : ndarray
        Boundary condition vector (lenght 3) at position x.
    &#34;&#34;&#34;
    # Check mode for free end
    mode = self.mode_td(l=l)
    # Get spring stiffness reduction factor
    kf = self.reduce_stiffness(l=l, mode=mode)
    # Get spring stiffness for collapsed weak-layer
    kR = self.calc_rot_spring(collapse=True)

    # Set boundary conditions for PST-systems
    if self.system in [&#39;pst-&#39;, &#39;-pst&#39;]:
        if not k:
            if mode in [&#39;A&#39;]:
                # Free end
                bc = np.array([self.N(z),
                               self.M(z),
                               self.V(z)
                               ])
            elif mode in [&#39;B&#39;, &#39;C&#39;] and pos in [&#39;r&#39;, &#39;right&#39;]:
                # Touchdown right
                bc = np.array([self.N(z),
                               self.M(z) + kf*kR*self.psi(z),
                               self.w(z)
                               ])
            elif mode in [&#39;B&#39;, &#39;C&#39;] and pos in [&#39;l&#39;, &#39;left&#39;]:
                # Touchdown left
                bc = np.array([self.N(z),
                               self.M(z) - kf*kR*self.psi(z),
                               self.w(z)
                               ])
        else:
            # Free end
            bc = np.array([self.N(z),
                            self.M(z),
                            self.V(z)
                            ])
    # Set boundary conditions for SKIER-systems
    elif self.system in [&#39;skier&#39;, &#39;skiers&#39;]:
        # Infinite end (vanishing complementary solution)
        bc = np.array([self.u(z, z0=0),
                       self.w(z),
                       self.psi(z)
                       ])
    else:
        raise ValueError(
            &#39;Boundary conditions not defined for&#39;
            f&#39;system of type {self.system}.&#39;)

    return bc</code></pre>
</details>
</dd>
<dt id="weac.mixins.SolutionMixin.calc_segments"><code class="name flex">
<span>def <span class="ident">calc_segments</span></span>(<span>self, tdi=False, li=False, mi=False, ki=False, k0=False, L=10000.0, a=0, m=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble lists defining the segments.</p>
<p>This includes length (li), foundation (ki, k0), and skier
weight (mi).</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>li</code></strong> :&ensp;<code>squence</code>, optional</dt>
<dd>List of lengths of segements(mm). Used for system 'skiers'.</dd>
<dt><strong><code>mi</code></strong> :&ensp;<code>squence</code>, optional</dt>
<dd>List of skier weigths (kg) at segement boundaries. Used for
system 'skiers'.</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>squence</code>, optional</dt>
<dd>List of one bool per segement indicating whether segement
has foundation (True) or not (False) in the cracked state.
Used for system 'skiers'.</dd>
<dt><strong><code>k0</code></strong> :&ensp;<code>squence</code>, optional</dt>
<dd>List of one bool per segement indicating whether segement
has foundation(True) or not (False) in the uncracked state.
Used for system 'skiers'.</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Total length of model (mm). Used for systems 'pst-', '-pst',
and 'skier'.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Crack length (mm).
Used for systems 'pst-', '-pst', and
'skier'.</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Inclination (degree).</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Weight of skier (kg) in the axial center of the model.
Used for system 'skier'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>segments</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with lists of touchdown booleans (tdi), segement
lengths (li), skier weights (mi), and foundation booleans
in the cracked (ki) and uncracked (k0) configurations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_segments(self, tdi=False, li=False, mi=False, ki=False, k0=False,
                  L=1e4, a=0, m=0, **kwargs):
    &#34;&#34;&#34;
    Assemble lists defining the segments.

    This includes length (li), foundation (ki, k0), and skier
    weight (mi).

    Arguments
    ---------
    li : squence, optional
        List of lengths of segements(mm). Used for system &#39;skiers&#39;.
    mi : squence, optional
        List of skier weigths (kg) at segement boundaries. Used for
        system &#39;skiers&#39;.
    ki : squence, optional
        List of one bool per segement indicating whether segement
        has foundation (True) or not (False) in the cracked state.
        Used for system &#39;skiers&#39;.
    k0 : squence, optional
        List of one bool per segement indicating whether segement
        has foundation(True) or not (False) in the uncracked state.
        Used for system &#39;skiers&#39;.
    L : float, optional
        Total length of model (mm). Used for systems &#39;pst-&#39;, &#39;-pst&#39;,
        and &#39;skier&#39;.
    a : float, optional
        Crack length (mm).  Used for systems &#39;pst-&#39;, &#39;-pst&#39;, and
        &#39;skier&#39;.
    phi : float, optional
        Inclination (degree).
    m : float, optional
        Weight of skier (kg) in the axial center of the model.
        Used for system &#39;skier&#39;.

    Returns
    -------
    segments : dict
        Dictionary with lists of touchdown booleans (tdi), segement
        lengths (li), skier weights (mi), and foundation booleans
        in the cracked (ki) and uncracked (k0) configurations.
    &#34;&#34;&#34;

    _ = kwargs                                      # Unused arguments
    # Set unbedded segment length
    mode = self.mode_td(l=a)
    if mode in [&#39;A&#39;, &#39;B&#39;]:
        lU = a
    if mode in [&#39;C&#39;]:
        lU = self.lS

    # Assemble list defining the segments
    if self.system == &#39;skiers&#39;:
        li = np.array(li)                           # Segment lengths
        mi = np.array(mi)                           # Skier weights
        ki = np.array(ki)                           # Crack
        k0 = np.array(k0)                           # No crack
    elif self.system == &#39;pst-&#39;:
        li = np.array([L - a, lU])                   # Segment lengths
        mi = np.array([0])                          # Skier weights
        ki = np.array([True, False])                # Crack
        k0 = np.array([True, True])                 # No crack
    elif self.system == &#39;-pst&#39;:
        li = np.array([lU, L - a])                   # Segment lengths
        mi = np.array([0])                          # Skier weights
        ki = np.array([False, True])                # Crack
        k0 = np.array([True, True])                 # No crack
    elif self.system == &#39;skier&#39;:
        lb = (L - a)/2                              # Half supported length
        lf = a/2                                    # Half free length
        li = np.array([lb, lf, lf, lb])             # Segment lengths
        mi = np.array([0, m, 0])                    # Skier weights
        ki = np.array([True, False, False, True])   # Crack
        k0 = np.array([True, True, True, True])     # No crack
    else:
        raise ValueError(f&#39;System {self.system} is not implemented.&#39;)

    # Fill dictionary
    segments = {
        &#39;nocrack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: k0},
        &#39;crack&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki},
        &#39;both&#39;: {&#39;li&#39;: li, &#39;mi&#39;: mi, &#39;ki&#39;: ki, &#39;k0&#39;: k0}}
    return segments</code></pre>
</details>
</dd>
<dt id="weac.mixins.SolutionMixin.eqs"><code class="name flex">
<span>def <span class="ident">eqs</span></span>(<span>self, zl, zr, l=0, k=False, pos='mid')</span>
</code></dt>
<dd>
<div class="desc"><p>Provide boundary or transmission conditions for beam segments.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>zl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector (6x1) at left end of beam segement.</dd>
<dt><strong><code>zr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Solution vector (6x1) at right end of beam segement.</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the segment in consideration. Default is zero.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Indicates whether segment has foundation(True) or not (False).
Default is False.</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>{'left', 'mid', 'right', 'l', 'm', 'r'}</code>, optional</dt>
<dd>Determines whether the segement under consideration
is a left boundary segement (left, l), one of the
center segement (mid, m), or a right boundary
segement (right, r). Default is 'mid'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eqs</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Vector (of length 9) of boundary conditions (3) and
transmission conditions (6) for boundary segements
or vector of transmission conditions (of length 6+6)
for center segments.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eqs(self, zl, zr, l=0, k=False, pos=&#39;mid&#39;):
    &#34;&#34;&#34;
    Provide boundary or transmission conditions for beam segments.

    Arguments
    ---------
    zl : ndarray
        Solution vector (6x1) at left end of beam segement.
    zr : ndarray
        Solution vector (6x1) at right end of beam segement.
    l : float, optional
        Length of the segment in consideration. Default is zero.
    k : boolean
        Indicates whether segment has foundation(True) or not (False).
        Default is False.
    pos: {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;, &#39;l&#39;, &#39;m&#39;, &#39;r&#39;}, optional
        Determines whether the segement under consideration
        is a left boundary segement (left, l), one of the
        center segement (mid, m), or a right boundary
        segement (right, r). Default is &#39;mid&#39;.

    Returns
    -------
    eqs : ndarray
        Vector (of length 9) of boundary conditions (3) and
        transmission conditions (6) for boundary segements
        or vector of transmission conditions (of length 6+6)
        for center segments.
    &#34;&#34;&#34;
    if pos in (&#39;l&#39;, &#39;left&#39;):
        eqs = np.array([
            self.bc(zl, l, k, pos)[0],             # Left boundary condition
            self.bc(zl, l, k, pos)[1],             # Left boundary condition
            self.bc(zl, l, k, pos)[2],             # Left boundary condition
            self.u(zr, z0=0),           # ui(xi = li)
            self.w(zr),                 # wi(xi = li)
            self.psi(zr),               # psii(xi = li)
            self.N(zr),                 # Ni(xi = li)
            self.M(zr),                 # Mi(xi = li)
            self.V(zr)])                # Vi(xi = li)
    elif pos in (&#39;m&#39;, &#39;mid&#39;):
        eqs = np.array([
            -self.u(zl, z0=0),          # -ui(xi = 0)
            -self.w(zl),                # -wi(xi = 0)
            -self.psi(zl),              # -psii(xi = 0)
            -self.N(zl),                # -Ni(xi = 0)
            -self.M(zl),                # -Mi(xi = 0)
            -self.V(zl),                # -Vi(xi = 0)
            self.u(zr, z0=0),           # ui(xi = li)
            self.w(zr),                 # wi(xi = li)
            self.psi(zr),               # psii(xi = li)
            self.N(zr),                 # Ni(xi = li)
            self.M(zr),                 # Mi(xi = li)
            self.V(zr)])                # Vi(xi = li)
    elif pos in (&#39;r&#39;, &#39;right&#39;):
        eqs = np.array([
            -self.u(zl, z0=0),          # -ui(xi = 0)
            -self.w(zl),                # -wi(xi = 0)
            -self.psi(zl),              # -psii(xi = 0)
            -self.N(zl),                # -Ni(xi = 0)
            -self.M(zl),                # -Mi(xi = 0)
            -self.V(zl),                # -Vi(xi = 0)
            self.bc(zr, l, k, pos)[0],             # Right boundary condition
            self.bc(zr, l, k, pos)[1],             # Right boundary condition
            self.bc(zr, l, k, pos)[2]])            # Right boundary condition
    else:
        raise ValueError(
            (f&#39;Invalid position argument {pos} given. &#39;
             &#39;Valid segment positions are l, m, and r, &#39;
             &#39;or left, mid and right.&#39;))
    return eqs</code></pre>
</details>
</dd>
<dt id="weac.mixins.SolutionMixin.mode_td"><code class="name flex">
<span>def <span class="ident">mode_td</span></span>(<span>self, l=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Identify the mode of the pst-boundary.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the segment in consideration. Default is zero.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code></dt>
<dd>Contains the mode for the boundary of the segment:
A - free end, B - intermediate touchdown,
C - full touchdown (maximum clamped end).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode_td(self, l=0):
    &#34;&#34;&#34;
    Identify the mode of the pst-boundary.

    Arguments
    ---------
    l : float, optional
        Length of the segment in consideration. Default is zero.

    Returns
    -------
    mode : string
        Contains the mode for the boundary of the segment:
        A - free end, B - intermediate touchdown,
        C - full touchdown (maximum clamped end).
    &#34;&#34;&#34;
    # Classify boundary type by element length
    if l &lt;= self.lC:
        mode = &#39;A&#39;
    elif self.lC &lt; l &lt;= self.lS:
        mode = &#39;B&#39;
    elif self.lS &lt; l:
        mode = &#39;C&#39;

    return mode</code></pre>
</details>
</dd>
<dt id="weac.mixins.SolutionMixin.reduce_stiffness"><code class="name flex">
<span>def <span class="ident">reduce_stiffness</span></span>(<span>self, l=0, mode='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the reduction factor for a rotational spring.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of the segment in consideration. Default is zero.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Contains the mode for the boundary of the segment:
A - free end, B - intermediate touchdown, C - full touchdown.
Default is A.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>kf</code></strong> :&ensp;<code>float</code></dt>
<dd>Reduction factor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_stiffness(self, l=0, mode=&#39;A&#39;):
    &#34;&#34;&#34;
    Determines the reduction factor for a rotational spring.

    Arguments
    ---------
    l : float, optional
        Length of the segment in consideration. Default is zero.
    mode : string, optional
        Contains the mode for the boundary of the segment:
        A - free end, B - intermediate touchdown, C - full touchdown.
        Default is A.

    Returns
    -------
    kf : float
        Reduction factor.
    &#34;&#34;&#34;
    # Reduction to zero for free end bc
    if mode in [&#39;A&#39;]:
        kf = 0
    # Reduction factor for touchdown
    if mode in [&#39;B&#39;, &#39;C&#39;]:
        l = l - self.lC
        # Beta needs to take into account different weak-layer spring stiffness
        beta = self.beta*self.ratio**(1/4)
        kf=(np.cos(2*beta*l)+np.cosh(2*beta*l)-2)/(np.sin(2*beta*l)+np.sinh(2*beta*l))

    return kf</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="weac" href="index.html">weac</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="weac.mixins.AnalysisMixin" href="#weac.mixins.AnalysisMixin">AnalysisMixin</a></code></h4>
<ul class="">
<li><code><a title="weac.mixins.AnalysisMixin.Sxx" href="#weac.mixins.AnalysisMixin.Sxx">Sxx</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.Szz" href="#weac.mixins.AnalysisMixin.Szz">Szz</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.Txz" href="#weac.mixins.AnalysisMixin.Txz">Txz</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.gdif" href="#weac.mixins.AnalysisMixin.gdif">gdif</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.get_zmesh" href="#weac.mixins.AnalysisMixin.get_zmesh">get_zmesh</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.ginc" href="#weac.mixins.AnalysisMixin.ginc">ginc</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.principal_stress_slab" href="#weac.mixins.AnalysisMixin.principal_stress_slab">principal_stress_slab</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.principal_stress_weaklayer" href="#weac.mixins.AnalysisMixin.principal_stress_weaklayer">principal_stress_weaklayer</a></code></li>
<li><code><a title="weac.mixins.AnalysisMixin.rasterize_solution" href="#weac.mixins.AnalysisMixin.rasterize_solution">rasterize_solution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weac.mixins.FieldQuantitiesMixin" href="#weac.mixins.FieldQuantitiesMixin">FieldQuantitiesMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="weac.mixins.FieldQuantitiesMixin.Gi" href="#weac.mixins.FieldQuantitiesMixin.Gi">Gi</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.Gii" href="#weac.mixins.FieldQuantitiesMixin.Gii">Gii</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.M" href="#weac.mixins.FieldQuantitiesMixin.M">M</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.N" href="#weac.mixins.FieldQuantitiesMixin.N">N</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.V" href="#weac.mixins.FieldQuantitiesMixin.V">V</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.dpsi_dx" href="#weac.mixins.FieldQuantitiesMixin.dpsi_dx">dpsi_dx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.dpsi_dxdx" href="#weac.mixins.FieldQuantitiesMixin.dpsi_dxdx">dpsi_dxdx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.dpsi_dxdxdx" href="#weac.mixins.FieldQuantitiesMixin.dpsi_dxdxdx">dpsi_dxdxdx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.du0_dxdx" href="#weac.mixins.FieldQuantitiesMixin.du0_dxdx">du0_dxdx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.du0_dxdxdx" href="#weac.mixins.FieldQuantitiesMixin.du0_dxdxdx">du0_dxdxdx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.du_dx" href="#weac.mixins.FieldQuantitiesMixin.du_dx">du_dx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.dw_dx" href="#weac.mixins.FieldQuantitiesMixin.dw_dx">dw_dx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.dz_dx" href="#weac.mixins.FieldQuantitiesMixin.dz_dx">dz_dx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.dz_dxdx" href="#weac.mixins.FieldQuantitiesMixin.dz_dxdx">dz_dxdx</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.eps" href="#weac.mixins.FieldQuantitiesMixin.eps">eps</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.gamma" href="#weac.mixins.FieldQuantitiesMixin.gamma">gamma</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.int1" href="#weac.mixins.FieldQuantitiesMixin.int1">int1</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.int2" href="#weac.mixins.FieldQuantitiesMixin.int2">int2</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.psi" href="#weac.mixins.FieldQuantitiesMixin.psi">psi</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.sig" href="#weac.mixins.FieldQuantitiesMixin.sig">sig</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.tau" href="#weac.mixins.FieldQuantitiesMixin.tau">tau</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.u" href="#weac.mixins.FieldQuantitiesMixin.u">u</a></code></li>
<li><code><a title="weac.mixins.FieldQuantitiesMixin.w" href="#weac.mixins.FieldQuantitiesMixin.w">w</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weac.mixins.OutputMixin" href="#weac.mixins.OutputMixin">OutputMixin</a></code></h4>
<ul class="">
<li><code><a title="weac.mixins.OutputMixin.get_slab_deflection" href="#weac.mixins.OutputMixin.get_slab_deflection">get_slab_deflection</a></code></li>
<li><code><a title="weac.mixins.OutputMixin.get_slab_displacement" href="#weac.mixins.OutputMixin.get_slab_displacement">get_slab_displacement</a></code></li>
<li><code><a title="weac.mixins.OutputMixin.get_slab_rotation" href="#weac.mixins.OutputMixin.get_slab_rotation">get_slab_rotation</a></code></li>
<li><code><a title="weac.mixins.OutputMixin.get_weaklayer_normalstress" href="#weac.mixins.OutputMixin.get_weaklayer_normalstress">get_weaklayer_normalstress</a></code></li>
<li><code><a title="weac.mixins.OutputMixin.get_weaklayer_shearstress" href="#weac.mixins.OutputMixin.get_weaklayer_shearstress">get_weaklayer_shearstress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="weac.mixins.SolutionMixin" href="#weac.mixins.SolutionMixin">SolutionMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="weac.mixins.SolutionMixin.assemble_and_solve" href="#weac.mixins.SolutionMixin.assemble_and_solve">assemble_and_solve</a></code></li>
<li><code><a title="weac.mixins.SolutionMixin.bc" href="#weac.mixins.SolutionMixin.bc">bc</a></code></li>
<li><code><a title="weac.mixins.SolutionMixin.calc_segments" href="#weac.mixins.SolutionMixin.calc_segments">calc_segments</a></code></li>
<li><code><a title="weac.mixins.SolutionMixin.eqs" href="#weac.mixins.SolutionMixin.eqs">eqs</a></code></li>
<li><code><a title="weac.mixins.SolutionMixin.mode_td" href="#weac.mixins.SolutionMixin.mode_td">mode_td</a></code></li>
<li><code><a title="weac.mixins.SolutionMixin.reduce_stiffness" href="#weac.mixins.SolutionMixin.reduce_stiffness">reduce_stiffness</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>